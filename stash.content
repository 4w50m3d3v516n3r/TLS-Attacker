diff --git a/Attacks/src/main/java/de/rub/nds/tlsattacker/attacks/ec/oracles/RealDirectMessageECOracle.java b/Attacks/src/main/java/de/rub/nds/tlsattacker/attacks/ec/oracles/RealDirectMessageECOracle.java
index e480d0ae..45db8fc6 100644
--- a/Attacks/src/main/java/de/rub/nds/tlsattacker/attacks/ec/oracles/RealDirectMessageECOracle.java
+++ b/Attacks/src/main/java/de/rub/nds/tlsattacker/attacks/ec/oracles/RealDirectMessageECOracle.java
@@ -73,7 +73,7 @@ public class RealDirectMessageECOracle extends ECOracle {
 
         WorkflowTrace trace = tlsContext.getWorkflowTrace();
         ECDHClientKeyExchangeMessage message = (ECDHClientKeyExchangeMessage) trace
-                .getFirstConfiguredSendMessageOfType(HandshakeMessageType.CLIENT_KEY_EXCHANGE);
+                .getFirstSendMessageOfType(HandshakeMessageType.CLIENT_KEY_EXCHANGE);
 
         // modify public point base X coordinate
         ModifiableBigInteger x = ModifiableVariableFactory.createBigIntegerModifiableVariable();
diff --git a/Attacks/src/main/java/de/rub/nds/tlsattacker/attacks/impl/BleichenbacherAttacker.java b/Attacks/src/main/java/de/rub/nds/tlsattacker/attacks/impl/BleichenbacherAttacker.java
index 46f9c324..98c72885 100644
--- a/Attacks/src/main/java/de/rub/nds/tlsattacker/attacks/impl/BleichenbacherAttacker.java
+++ b/Attacks/src/main/java/de/rub/nds/tlsattacker/attacks/impl/BleichenbacherAttacker.java
@@ -64,7 +64,7 @@ public class BleichenbacherAttacker extends Attacker<BleichenbacherCommandConfig
                 tlsContext);
         WorkflowTrace trace = tlsContext.getWorkflowTrace();
         RSAClientKeyExchangeMessage cke = (RSAClientKeyExchangeMessage) trace
-                .getFirstConfiguredSendMessageOfType(HandshakeMessageType.CLIENT_KEY_EXCHANGE);
+                .getFirstSendMessageOfType(HandshakeMessageType.CLIENT_KEY_EXCHANGE);
         ModifiableByteArray epms = new ModifiableByteArray();
         epms.setModification(ByteArrayModificationFactory.explicitValue(encryptedPMS));
         cke.setPublicKey(epms);
diff --git a/Attacks/src/main/java/de/rub/nds/tlsattacker/attacks/impl/Cve20162107Attacker.java b/Attacks/src/main/java/de/rub/nds/tlsattacker/attacks/impl/Cve20162107Attacker.java
index d4eebb93..3226f7bd 100644
--- a/Attacks/src/main/java/de/rub/nds/tlsattacker/attacks/impl/Cve20162107Attacker.java
+++ b/Attacks/src/main/java/de/rub/nds/tlsattacker/attacks/impl/Cve20162107Attacker.java
@@ -73,18 +73,18 @@ public class Cve20162107Attacker extends Attacker<Cve20162107CommandConfig> {
         TlsContext tlsContext = new TlsContext(tlsConfig);
 
         WorkflowTrace trace = new WorkflowConfigurationFactory(tlsConfig).createHandshakeWorkflow();
-        SendAction sendAction = trace.getFirstConfiguredSendActionWithType(HandshakeMessageType.FINISHED);
+        SendAction sendAction = trace.getFirstSendActionWithType(HandshakeMessageType.FINISHED);
         // We need 2-3 Records,one for every message, while the last one will
         // have the modified padding
         List<AbstractRecord> records = new LinkedList<>();
         Record record = createRecordWithBadPadding();
         tlsConfig.setCreateIndividualRecords(true);
         records.add(new Record(tlsConfig));
-        if (sendAction.getConfiguredMessages().size() > 2) {
+        if (sendAction.getMessages().size() > 2) {
             records.add(new Record(tlsConfig));
         }
         records.add(record);
-        sendAction.setConfiguredRecords(records);
+        sendAction.setRecords(records);
 
         // Remove last two server messages (CCS and Finished). Instead of them,
         // an alert will be sent.
@@ -93,7 +93,7 @@ public class Cve20162107Attacker extends Attacker<Cve20162107CommandConfig> {
         ReceiveAction action = (ReceiveAction) (trace.getLastMessageAction());
         List<ProtocolMessage> messages = new LinkedList<>();
         messages.add(alertMessage);
-        action.setConfiguredMessages(messages);
+        action.setMessages(messages);
         tlsConfig.setWorkflowTrace(trace);
         WorkflowExecutor workflowExecutor = WorkflowExecutorFactory.createWorkflowExecutor(tlsConfig.getExecutorType(),
                 tlsContext);
diff --git a/Attacks/src/main/java/de/rub/nds/tlsattacker/attacks/impl/DtlsPaddingOracleAttacker.java b/Attacks/src/main/java/de/rub/nds/tlsattacker/attacks/impl/DtlsPaddingOracleAttacker.java
index 1b875f2b..ccf5aa51 100644
--- a/Attacks/src/main/java/de/rub/nds/tlsattacker/attacks/impl/DtlsPaddingOracleAttacker.java
+++ b/Attacks/src/main/java/de/rub/nds/tlsattacker/attacks/impl/DtlsPaddingOracleAttacker.java
@@ -32,7 +32,7 @@ import de.rub.nds.tlsattacker.core.workflow.WorkflowTrace;
 import de.rub.nds.tlsattacker.core.workflow.action.SendAction;
 import de.rub.nds.tlsattacker.core.workflow.action.TLSAction;
 import de.rub.nds.tlsattacker.core.workflow.action.executor.ExecutorType;
-import de.rub.nds.tlsattacker.transport.UDPTransportHandler;
+import de.rub.nds.tlsattacker.transport.UDPClientTransportHandler;
 import de.rub.nds.modifiablevariable.util.RandomHelper;
 import de.rub.nds.tlsattacker.core.workflow.chooser.DefaultChooser;
 import java.io.FileWriter;
@@ -59,7 +59,7 @@ public class DtlsPaddingOracleAttacker extends Attacker<DtlsPaddingOracleAttackC
 
     private RecordLayer recordLayer;
     private List<TLSAction> actionList;
-    private UDPTransportHandler transportHandler;
+    private UDPClientTransportHandler transportHandler;
 
     private final ModifiableByteArray modifiedPaddingArray = new ModifiableByteArray(),
             modifiedMacArray = new ModifiableByteArray();
@@ -237,7 +237,7 @@ public class DtlsPaddingOracleAttacker extends Attacker<DtlsPaddingOracleAttackC
         }
 
         records.add(new Record());
-        action.getConfiguredMessages().add(heartbeatMessage);
+        action.getMessages().add(heartbeatMessage);
         train[n] = recordLayer.prepareRecords(heartbeatMessage.getCompleteResultingMessage().getValue(),
                 ProtocolMessageType.HEARTBEAT, records);
 
@@ -266,7 +266,7 @@ public class DtlsPaddingOracleAttacker extends Attacker<DtlsPaddingOracleAttackC
 
         records.remove(0);
         records.add(new Record());
-        action.getConfiguredMessages().add(heartbeatMessage);
+        action.getMessages().add(heartbeatMessage);
         train[n] = (recordLayer.prepareRecords(heartbeatMessage.getCompleteResultingMessage().getValue(),
                 ProtocolMessageType.HEARTBEAT, records));
 
diff --git a/Attacks/src/main/java/de/rub/nds/tlsattacker/attacks/impl/HeartbleedAttacker.java b/Attacks/src/main/java/de/rub/nds/tlsattacker/attacks/impl/HeartbleedAttacker.java
index 4758bdce..bfae0668 100644
--- a/Attacks/src/main/java/de/rub/nds/tlsattacker/attacks/impl/HeartbleedAttacker.java
+++ b/Attacks/src/main/java/de/rub/nds/tlsattacker/attacks/impl/HeartbleedAttacker.java
@@ -63,7 +63,7 @@ public class HeartbleedAttacker extends Attacker<HeartbleedCommandConfig> {
         ModifiableByteArray payload = new ModifiableByteArray();
         payload.setModification(ByteArrayModificationFactory.explicitValue(new byte[] { 1, 3 }));
         HeartbeatMessage hb = (HeartbeatMessage) trace
-                .getFirstConfiguredSendMessageOfType(ProtocolMessageType.HEARTBEAT);
+                .getFirstSendMessageOfType(ProtocolMessageType.HEARTBEAT);
         hb.setHeartbeatMessageType(heartbeatMessageType);
         hb.setPayload(payload);
         hb.setPayloadLength(payloadLength);
diff --git a/Attacks/src/main/java/de/rub/nds/tlsattacker/attacks/impl/InvalidCurveAttacker.java b/Attacks/src/main/java/de/rub/nds/tlsattacker/attacks/impl/InvalidCurveAttacker.java
index 47e750fc..4105f86b 100644
--- a/Attacks/src/main/java/de/rub/nds/tlsattacker/attacks/impl/InvalidCurveAttacker.java
+++ b/Attacks/src/main/java/de/rub/nds/tlsattacker/attacks/impl/InvalidCurveAttacker.java
@@ -82,7 +82,7 @@ public class InvalidCurveAttacker extends Attacker<InvalidCurveAttackConfig> {
                 tlsContext);
         WorkflowTrace trace = tlsContext.getWorkflowTrace();
         ECDHClientKeyExchangeMessage message = (ECDHClientKeyExchangeMessage) trace
-                .getFirstConfiguredSendMessageOfType(HandshakeMessageType.CLIENT_KEY_EXCHANGE);
+                .getFirstSendMessageOfType(HandshakeMessageType.CLIENT_KEY_EXCHANGE);
         // modify public point base X coordinate
         ModifiableBigInteger x = ModifiableVariableFactory.createBigIntegerModifiableVariable();
         x.setModification(BigIntegerModificationFactory.explicitValue(config.getPublicPointBaseX()));
diff --git a/Attacks/src/main/java/de/rub/nds/tlsattacker/attacks/impl/Lucky13Attacker.java b/Attacks/src/main/java/de/rub/nds/tlsattacker/attacks/impl/Lucky13Attacker.java
index 2eed57e6..e18f8bc7 100644
--- a/Attacks/src/main/java/de/rub/nds/tlsattacker/attacks/impl/Lucky13Attacker.java
+++ b/Attacks/src/main/java/de/rub/nds/tlsattacker/attacks/impl/Lucky13Attacker.java
@@ -129,7 +129,7 @@ public class Lucky13Attacker extends Attacker<Lucky13CommandConfig> {
         ApplicationMessage applicationMessage = new ApplicationMessage(tlsConfig);
         SendAction action = new SendAction(applicationMessage);
         trace.add(action);
-        action.getConfiguredRecords().add(record);
+        action.getRecords().add(record);
         // Server
         AlertMessage alertMessage = new AlertMessage(tlsConfig);
         trace.add(new ReceiveAction(alertMessage));
diff --git a/Attacks/src/main/java/de/rub/nds/tlsattacker/attacks/impl/PaddingOracleAttacker.java b/Attacks/src/main/java/de/rub/nds/tlsattacker/attacks/impl/PaddingOracleAttacker.java
index 9339e0e4..ea97faae 100644
--- a/Attacks/src/main/java/de/rub/nds/tlsattacker/attacks/impl/PaddingOracleAttacker.java
+++ b/Attacks/src/main/java/de/rub/nds/tlsattacker/attacks/impl/PaddingOracleAttacker.java
@@ -68,8 +68,8 @@ public class PaddingOracleAttacker extends Attacker<PaddingOracleCommandConfig>
 
         ApplicationMessage applicationMessage = new ApplicationMessage(tlsConfig);
         SendAction sendAction = new SendAction(applicationMessage);
-        sendAction.setConfiguredRecords(new LinkedList<AbstractRecord>());
-        sendAction.getConfiguredRecords().add(record);
+        sendAction.setRecords(new LinkedList<AbstractRecord>());
+        sendAction.getRecords().add(record);
         trace.add(sendAction);
         AlertMessage alertMessage = new AlertMessage(tlsConfig);
         trace.add(new ReceiveAction(alertMessage));
diff --git a/Attacks/src/main/java/de/rub/nds/tlsattacker/attacks/impl/TLSPoodleAttacker.java b/Attacks/src/main/java/de/rub/nds/tlsattacker/attacks/impl/TLSPoodleAttacker.java
index 783c6f13..c443cb23 100644
--- a/Attacks/src/main/java/de/rub/nds/tlsattacker/attacks/impl/TLSPoodleAttacker.java
+++ b/Attacks/src/main/java/de/rub/nds/tlsattacker/attacks/impl/TLSPoodleAttacker.java
@@ -63,7 +63,7 @@ public class TLSPoodleAttacker extends Attacker<TLSPoodleCommandConfig> {
         Record r = new Record();
         r.setPadding(padding);
         SendAction sendAction = new SendAction(applicationMessage);
-        sendAction.getConfiguredRecords().add(r);
+        sendAction.getRecords().add(r);
         AlertMessage alertMessage = new AlertMessage(tlsConfig);
         trace.add(new SendAction(applicationMessage));
         trace.add(new ReceiveAction(alertMessage));
diff --git a/Attacks/src/main/java/de/rub/nds/tlsattacker/attacks/impl/WinshockAttacker.java b/Attacks/src/main/java/de/rub/nds/tlsattacker/attacks/impl/WinshockAttacker.java
index a4ad0a88..e9d3a157 100644
--- a/Attacks/src/main/java/de/rub/nds/tlsattacker/attacks/impl/WinshockAttacker.java
+++ b/Attacks/src/main/java/de/rub/nds/tlsattacker/attacks/impl/WinshockAttacker.java
@@ -60,7 +60,7 @@ public class WinshockAttacker extends Attacker<WinshockCommandConfig> {
         }
 
         CertificateVerifyMessage cvm = (CertificateVerifyMessage) trace
-                .getFirstConfiguredSendMessageOfType(HandshakeMessageType.CERTIFICATE_VERIFY);
+                .getFirstSendMessageOfType(HandshakeMessageType.CERTIFICATE_VERIFY);
         cvm.setSignature(signature);
         cvm.setSignatureLength(signatureLength);
 
diff --git a/TLS-Client/src/test/java/de/rub/nds/tlsattacker/client/main/TlsClientTest.java b/TLS-Client/src/test/java/de/rub/nds/tlsattacker/client/main/TlsClientTest.java
index c56e6f7d..eca4d030 100644
--- a/TLS-Client/src/test/java/de/rub/nds/tlsattacker/client/main/TlsClientTest.java
+++ b/TLS-Client/src/test/java/de/rub/nds/tlsattacker/client/main/TlsClientTest.java
@@ -57,8 +57,10 @@ import de.rub.nds.tlsattacker.core.workflow.TlsContext;
 import de.rub.nds.tlsattacker.core.workflow.WorkflowExecutor;
 import de.rub.nds.tlsattacker.core.workflow.WorkflowExecutorFactory;
 import de.rub.nds.tlsattacker.core.workflow.WorkflowTrace;
+import de.rub.nds.tlsattacker.core.workflow.action.FastReceiveAction;
 import de.rub.nds.tlsattacker.core.workflow.factory.WorkflowTraceType;
 import de.rub.nds.tlsattacker.core.workflow.action.MessageActionFactory;
+import de.rub.nds.tlsattacker.core.workflow.action.TLSAction;
 import de.rub.nds.tlsattacker.transport.ConnectionEndType;
 import de.rub.nds.tlsattacker.util.FixedTimeProvider;
 import de.rub.nds.tlsattacker.util.TimeHelper;
@@ -188,13 +190,35 @@ public class TlsClientTest {
             E.printStackTrace();
         }
         String workflowString = tlsContext.getWorkflowTrace().toString();
-        boolean result = tlsContext.getWorkflowTrace().configuredLooksLikeActual();
+        boolean result = configuredLoosLikeActual(tlsContext.getWorkflowTrace());
         if (!result) {
             LOGGER.info(workflowString);
             return result;
         }
         return result;
     }
+    
+    private boolean configuredLoosLikeActual(WorkflowTrace trace)
+    {
+        List<TLSAction> actions = trace.getTLSActions();
+        for(TLSAction action : actions)
+        {
+            if(!action.isExecuted())
+            {
+                return false;
+            }
+            if(action instanceof FastReceiveAction)
+            {
+                FastReceiveAction fastAction = (FastReceiveAction) action;
+                if(!fastAction.getReceivedExpected())
+                {
+                    return false;
+                }
+            }
+        }
+        return true;
+        
+    }
 
     private boolean testCustomWorkflow(int port) {
         ClientCommandConfig clientCommandConfig = new ClientCommandConfig(new GeneralDelegate());
@@ -227,7 +251,7 @@ public class TlsClientTest {
             return false;
         }
 
-        return trace.configuredLooksLikeActual();
+        return configuredLoosLikeActual(trace);
     }
 
 }
diff --git a/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/protocol/message/ServerKeyExchangeMessage.java b/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/protocol/message/ServerKeyExchangeMessage.java
index 9bda964b..5d5ddc8d 100644
--- a/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/protocol/message/ServerKeyExchangeMessage.java
+++ b/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/protocol/message/ServerKeyExchangeMessage.java
@@ -8,12 +8,10 @@
  */
 package de.rub.nds.tlsattacker.core.protocol.message;
 
-import de.rub.nds.modifiablevariable.ModifiableVariable;
 import de.rub.nds.modifiablevariable.ModifiableVariableFactory;
 import de.rub.nds.modifiablevariable.ModifiableVariableProperty;
 import de.rub.nds.modifiablevariable.bytearray.ModifiableByteArray;
 import de.rub.nds.modifiablevariable.integer.ModifiableInteger;
-import de.rub.nds.modifiablevariable.singlebyte.ModifiableByte;
 import de.rub.nds.tlsattacker.core.constants.HandshakeMessageType;
 import de.rub.nds.tlsattacker.core.protocol.message.computations.KeyExchangeComputations;
 import de.rub.nds.tlsattacker.core.workflow.TlsConfig;
@@ -28,12 +26,8 @@ public abstract class ServerKeyExchangeMessage extends HandshakeMessage {
      * hash algorithm
      */
     @ModifiableVariableProperty(type = ModifiableVariableProperty.Type.TLS_CONSTANT)
-    private ModifiableByte hashAlgorithm;
-    /**
-     * signature algorithm
-     */
-    @ModifiableVariableProperty(type = ModifiableVariableProperty.Type.TLS_CONSTANT)
-    private ModifiableByte signatureAlgorithm;
+    private ModifiableByteArray signatureHashAlgorithm;
+    
     /**
      * signature length
      */
@@ -68,28 +62,16 @@ public abstract class ServerKeyExchangeMessage extends HandshakeMessage {
 
     public abstract void prepareComputations();
 
-    public ModifiableVariable<Byte> getHashAlgorithm() {
-        return hashAlgorithm;
-    }
-
-    public void setHashAlgorithm(ModifiableByte hashAlgorithm) {
-        this.hashAlgorithm = hashAlgorithm;
-    }
-
-    public void setHashAlgorithm(byte algorithm) {
-        this.hashAlgorithm = ModifiableVariableFactory.safelySetValue(this.hashAlgorithm, algorithm);
-    }
-
-    public ModifiableVariable<Byte> getSignatureAlgorithm() {
-        return signatureAlgorithm;
+    public ModifiableByteArray getSignatureHashAlgorithm() {
+        return signatureHashAlgorithm;
     }
 
-    public void setSignatureAlgorithm(ModifiableByte signatureAlgorithm) {
-        this.signatureAlgorithm = signatureAlgorithm;
+    public void setSignatureHashAlgorithm(ModifiableByteArray signatureHashAlgorithm) {
+        this.signatureHashAlgorithm = signatureHashAlgorithm;
     }
 
-    public void setSignatureAlgorithm(byte algorithm) {
-        this.signatureAlgorithm = ModifiableVariableFactory.safelySetValue(this.signatureAlgorithm, algorithm);
+    public void setSignatureHashAlgorithm(byte[] signatureHashAlgorithm) {
+        this.signatureHashAlgorithm = ModifiableVariableFactory.safelySetValue(this.signatureHashAlgorithm, signatureHashAlgorithm);
     }
 
     public ModifiableInteger getSignatureLength() {
diff --git a/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/protocol/parser/DHEServerKeyExchangeParser.java b/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/protocol/parser/DHEServerKeyExchangeParser.java
index d2c596ef..d61bffc6 100644
--- a/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/protocol/parser/DHEServerKeyExchangeParser.java
+++ b/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/protocol/parser/DHEServerKeyExchangeParser.java
@@ -170,7 +170,7 @@ public class DHEServerKeyExchangeParser extends ServerKeyExchangeParser<DHEServe
      *            Message to write in
      */
     private void parseSignatureAlgorithm(DHEServerKeyExchangeMessage msg) {
-        msg.setSignatureAlgorithm(parseByteField(HandshakeByteLength.SIGNATURE));
+        msg.setSignatureHashAlgorithm(parseByteField(HandshakeByteLength.SIGNATURE));
         LOGGER.debug("SignatureAlgorithm: " + msg.getSignatureAlgorithm().getValue());
     }
 
diff --git a/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/protocol/parser/ECDHEServerKeyExchangeParser.java b/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/protocol/parser/ECDHEServerKeyExchangeParser.java
index 8b6b99e5..650ce5be 100644
--- a/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/protocol/parser/ECDHEServerKeyExchangeParser.java
+++ b/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/protocol/parser/ECDHEServerKeyExchangeParser.java
@@ -147,7 +147,7 @@ public class ECDHEServerKeyExchangeParser extends ServerKeyExchangeParser<ECDHES
      *            Message to write in
      */
     private void parseSignatureAlgorithm(ECDHEServerKeyExchangeMessage msg) {
-        msg.setSignatureAlgorithm(parseByteField(HandshakeByteLength.SIGNATURE));
+        msg.setSignatureHashAlgorithm(parseByteField(HandshakeByteLength.SIGNATURE));
         LOGGER.debug("SignatureAlgorithm: " + msg.getSignatureAlgorithm().getValue());
     }
 
diff --git a/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/protocol/preparator/DHEServerKeyExchangePreparator.java b/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/protocol/preparator/DHEServerKeyExchangePreparator.java
index 231fdf0b..34d53f53 100644
--- a/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/protocol/preparator/DHEServerKeyExchangePreparator.java
+++ b/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/protocol/preparator/DHEServerKeyExchangePreparator.java
@@ -123,7 +123,7 @@ public class DHEServerKeyExchangePreparator extends ServerKeyExchangePreparator<
     }
 
     private void prepareSignatureAlgorithm(DHEServerKeyExchangeMessage msg) {
-        msg.setSignatureAlgorithm(selectedSignatureHashAlgo.getSignatureAlgorithm().getValue());
+        msg.setSignatureHashAlgorithm(selectedSignatureHashAlgo.getSignatureAlgorithm().getValue());
         LOGGER.debug("SignatureAlgorithm: " + msg.getSignatureAlgorithm().getValue());
     }
 
diff --git a/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/protocol/preparator/ECDHEServerKeyExchangePreparator.java b/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/protocol/preparator/ECDHEServerKeyExchangePreparator.java
index 95b568a9..a645f75e 100644
--- a/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/protocol/preparator/ECDHEServerKeyExchangePreparator.java
+++ b/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/protocol/preparator/ECDHEServerKeyExchangePreparator.java
@@ -224,7 +224,7 @@ public class ECDHEServerKeyExchangePreparator extends ServerKeyExchangePreparato
     }
 
     private void prepareSignatureAlgorithm(ECDHEServerKeyExchangeMessage msg, SignatureAndHashAlgorithm signHashAlgo) {
-        msg.setSignatureAlgorithm(signHashAlgo.getSignatureAlgorithm().getValue());
+        msg.setSignatureHashAlgorithm(signHashAlgo.getSignatureAlgorithm().getValue());
         LOGGER.debug("SignatureAlgorithm: " + msg.getSignatureAlgorithm().getValue());
     }
 
diff --git a/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/DefaultWorkflowExecutor.java b/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/DefaultWorkflowExecutor.java
index 1473d177..8dc2292f 100644
--- a/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/DefaultWorkflowExecutor.java
+++ b/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/DefaultWorkflowExecutor.java
@@ -10,12 +10,16 @@ package de.rub.nds.tlsattacker.core.workflow;
 
 import de.rub.nds.tlsattacker.core.exceptions.PreparationException;
 import de.rub.nds.tlsattacker.core.exceptions.WorkflowExecutionException;
+import de.rub.nds.tlsattacker.core.protocol.message.ProtocolMessage;
+import de.rub.nds.tlsattacker.core.record.AbstractRecord;
 import de.rub.nds.tlsattacker.core.record.layer.RecordLayerFactory;
 import de.rub.nds.tlsattacker.core.workflow.action.TLSAction;
 import de.rub.nds.tlsattacker.core.workflow.action.executor.ActionExecutor;
 import de.rub.nds.tlsattacker.core.workflow.action.executor.ActionExecutorFactory;
 import de.rub.nds.tlsattacker.core.workflow.action.executor.ExecutorType;
+import de.rub.nds.tlsattacker.core.workflow.action.executor.MessageActionResult;
 import java.io.IOException;
+import java.util.LinkedList;
 import java.util.List;
 
 /**
@@ -40,7 +44,11 @@ public class DefaultWorkflowExecutor extends WorkflowExecutor {
         List<TLSAction> tlsActions = context.getWorkflowTrace().getTLSActions();
         for (TLSAction action : tlsActions) {
             try {
-                action.execute(context, actionExecutor);
+                if ((context.getConfig().isStopRecievingAfterFatal() && context.isReceivedFatalAlert())) {
+                    LOGGER.debug("Skipping action:"+ action.toString());
+                } else {
+                    action.execute(context);
+                }
             } catch (IOException | PreparationException ex) {
                 throw new WorkflowExecutionException("Problem while executing Action:" + action.toString(), ex);
             }
diff --git a/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/TlsConfig.java b/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/TlsConfig.java
index 0e16b327..bb5e54c1 100644
--- a/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/TlsConfig.java
+++ b/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/TlsConfig.java
@@ -451,7 +451,7 @@ public class TlsConfig implements Serializable {
 
     private BigInteger defaultClientRSAPrivateKey = new BigInteger(
             "89489425009274444368228545921773093919669586065884257445497854456487674839629818390934941973262879616797970608917283679875499331574161113854088813275488110588247193077582527278437906504015680623423550067240042466665654232383502922215493623289472138866445818789127946123407807725702626644091036502372545139713");
-
+    
     private TlsConfig() {
         supportedSignatureAndHashAlgorithms = new LinkedList<>();
         supportedSignatureAndHashAlgorithms.add(new SignatureAndHashAlgorithm(SignatureAlgorithm.RSA,
diff --git a/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/WorkflowTrace.java b/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/WorkflowTrace.java
index 01b74035..abd395e0 100644
--- a/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/WorkflowTrace.java
+++ b/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/WorkflowTrace.java
@@ -95,8 +95,8 @@ public class WorkflowTrace implements Serializable {
      */
     public void makeGeneric() {
         for (ReceiveAction action : getReceiveActions()) {
-            action.getConfiguredMessages().clear();
-            action.getConfiguredMessages().add(new ArbitraryMessage());
+            action.getMessages().clear();
+            action.getMessages().add(new ArbitraryMessage());
         }
     }
 
@@ -109,10 +109,7 @@ public class WorkflowTrace implements Serializable {
         List<MessageAction> messageActions = getMessageActions();
         List<ModifiableVariableHolder> holders = new LinkedList<>();
         for (MessageAction action : messageActions) {
-            for (ProtocolMessage message : action.getActualMessages()) {
-                holders.addAll(message.getAllModifiableVariableHolders());
-            }
-            for (ProtocolMessage message : action.getConfiguredMessages()) {
+            for (ProtocolMessage message : action.getMessages()) {
                 holders.addAll(message.getAllModifiableVariableHolders());
             }
         }
@@ -237,96 +234,40 @@ public class WorkflowTrace implements Serializable {
         return returnedMessages;
     }
 
-    public ProtocolMessage getFirstConfiguredSendMessageOfType(ProtocolMessageType type) {
-        return filterMessageList(getAllConfiguredSendMessages(), type).get(0);
+    public ProtocolMessage getFirstSendMessageOfType(ProtocolMessageType type) {
+        return filterMessageList(getAllSendMessages(), type).get(0);
     }
 
-    public HandshakeMessage getFirstConfiguredSendMessageOfType(HandshakeMessageType type) {
+    public HandshakeMessage getFirstSendMessageOfType(HandshakeMessageType type) {
         List<HandshakeMessage> list = filterMessageList(
-                filterHandshakeMessagesFromList(getAllConfiguredSendMessages()), type);
-        if (list.size() > 0) {
-            return list.get(0);
-        }
-        return null;
-    }
-
-    public ProtocolMessage getFirstActuallySendMessageOfType(ProtocolMessageType type) {
-        List<ProtocolMessage> list = filterMessageList(getAllActuallySentMessages(), type);
+                filterHandshakeMessagesFromList(getAllSendMessages()), type);
         if (list.size() > 0) {
             return list.get(0);
         }
         return null;
     }
-
-    public HandshakeMessage getFirstActuallySendMessageOfType(HandshakeMessageType type) {
-        return filterMessageList(filterHandshakeMessagesFromList(getAllActuallySentMessages()), type).get(0);
-    }
-
-    public List<ProtocolMessage> getActualReceivedProtocolMessagesOfType(ProtocolMessageType type) {
-        return filterMessageList(getAllActuallyReceivedMessages(), type);
-    }
-
-    public List<HandshakeMessage> getActuallyRecievedHandshakeMessagesOfType(HandshakeMessageType type) {
-        return filterMessageList(filterHandshakeMessagesFromList(getAllActuallyReceivedMessages()), type);
-    }
-
-    public List<ProtocolMessage> getActuallyRecievedProtocolMessagesOfType(ProtocolMessageType type) {
-        return filterMessageList(getAllActuallyReceivedMessages(), type);
-    }
-
-    public List<HandshakeMessage> getActuallySentHandshakeMessagesOfType(HandshakeMessageType type) {
-        return filterMessageList(filterHandshakeMessagesFromList(getAllActuallySentMessages()), type);
-    }
-
-    public List<ProtocolMessage> getActuallySentProtocolMessagesOfType(ProtocolMessageType type) {
-        return filterMessageList(getAllActuallySentMessages(), type);
-    }
-
-    public List<HandshakeMessage> getConfiguredRecievedHandshakeMessagesOfType(HandshakeMessageType type) {
-        return filterMessageList(filterHandshakeMessagesFromList(getAllConfiguredReceivingMessages()), type);
+    
+    public List<HandshakeMessage> getRecievedHandshakeMessagesOfType(HandshakeMessageType type) {
+        return filterMessageList(filterHandshakeMessagesFromList(getAllReceiveMessages()), type);
     }
 
-    public List<ProtocolMessage> getConfiguredRecievedProtocolMessagesOfType(ProtocolMessageType type) {
-        return filterMessageList(getAllConfiguredReceivingMessages(), type);
+    public List<ProtocolMessage> getRecievedProtocolMessagesOfType(ProtocolMessageType type) {
+        return filterMessageList(getAllReceiveMessages(), type);
     }
 
-    public List<HandshakeMessage> getConfiguredSentHandshakeMessagesOfType(HandshakeMessageType type) {
-        return filterMessageList(filterHandshakeMessagesFromList(getAllConfiguredSendMessages()), type);
+    public List<HandshakeMessage> getSendHandshakeMessagesOfType(HandshakeMessageType type) {
+        return filterMessageList(filterHandshakeMessagesFromList(getAllSendMessages()), type);
     }
 
-    public List<ProtocolMessage> getConfiguredSendProtocolMessagesOfType(ProtocolMessageType type) {
-        return filterMessageList(getAllConfiguredSendMessages(), type);
+    public List<ProtocolMessage> getSendProtocolMessagesOfType(ProtocolMessageType type) {
+        return filterMessageList(getAllSendMessages(), type);
     }
 
-    public List<ProtocolMessage> getAllConfiguredMessages() {
+    public List<ProtocolMessage> getAllMessages() {
         List<ProtocolMessage> messages = new LinkedList<>();
         for (TLSAction action : tlsActions) {
             if (action.isMessageAction()) {
-                for (ProtocolMessage pm : ((MessageAction) action).getConfiguredMessages()) {
-                    messages.add(pm);
-                }
-            }
-        }
-        return messages;
-    }
-
-    public List<ProtocolMessage> getAllActualMessages() {
-        List<ProtocolMessage> messages = new LinkedList<>();
-        for (TLSAction action : tlsActions) {
-            if (action instanceof MessageAction) {
-                for (ProtocolMessage pm : ((MessageAction) action).getActualMessages()) {
-                    messages.add(pm);
-                }
-            }
-        }
-        return messages;
-    }
-
-    public List<ProtocolMessage> getAllConfiguredReceivingMessages() {
-        List<ProtocolMessage> messages = new LinkedList<>();
-        for (TLSAction action : tlsActions) {
-            if (action instanceof ReceiveAction) {
-                for (ProtocolMessage pm : ((MessageAction) action).getConfiguredMessages()) {
+                for (ProtocolMessage pm : ((MessageAction) action).getMessages()) {
                     messages.add(pm);
                 }
             }
@@ -334,25 +275,11 @@ public class WorkflowTrace implements Serializable {
         return messages;
     }
 
-    public List<ProtocolMessage> getAllActuallyReceivedMessages() {
+    public List<ProtocolMessage> getAllReceiveMessages() {
         List<ProtocolMessage> messages = new LinkedList<>();
         for (TLSAction action : tlsActions) {
             if (action instanceof ReceiveAction) {
-                for (ProtocolMessage pm : ((MessageAction) action).getActualMessages()) {
-
-                    messages.add(pm);
-
-                }
-            }
-        }
-        return messages;
-    }
-
-    public List<ProtocolMessage> getAllConfiguredSendMessages() {
-        List<ProtocolMessage> messages = new LinkedList<>();
-        for (TLSAction action : tlsActions) {
-            if (action instanceof SendAction) {
-                for (ProtocolMessage pm : ((MessageAction) action).getConfiguredMessages()) {
+                for (ProtocolMessage pm : ((MessageAction) action).getMessages()) {
                     messages.add(pm);
                 }
             }
@@ -360,11 +287,11 @@ public class WorkflowTrace implements Serializable {
         return messages;
     }
 
-    public List<ProtocolMessage> getAllActuallySentMessages() {
+    public List<ProtocolMessage> getAllSendMessages() {
         List<ProtocolMessage> messages = new LinkedList<>();
         for (TLSAction action : tlsActions) {
             if (action instanceof SendAction) {
-                for (ProtocolMessage pm : ((MessageAction) action).getActualMessages()) {
+                for (ProtocolMessage pm : ((MessageAction) action).getMessages()) {
                     messages.add(pm);
                 }
             }
@@ -386,82 +313,33 @@ public class WorkflowTrace implements Serializable {
         return null;
     }
 
-    public ProtocolMessage getLastConfiguredReceiveMesssage() {
-        List<ProtocolMessage> messages = getAllConfiguredReceivingMessages();
+    public ProtocolMessage getLastReceiveMesssage() {
+        List<ProtocolMessage> messages = getAllReceiveMessages();
         if (messages.size() > 0) {
             return messages.get(0);
         }
         return null;
     }
 
-    public ProtocolMessage getLastConfiguredSendMesssage() {
-        List<ProtocolMessage> clientMessages = getAllConfiguredSendMessages();
+    public ProtocolMessage getLastSendMesssage() {
+        List<ProtocolMessage> clientMessages = getAllSendMessages();
         int size = clientMessages.size();
         return clientMessages.get(size - 1);
     }
 
-    public boolean containsConfiguredReceivedProtocolMessage(ProtocolMessageType type) {
-        return !getConfiguredRecievedProtocolMessagesOfType(type).isEmpty();
-    }
-
-    public boolean containsConfiguredSendProtocolMessage(ProtocolMessageType type) {
-        return !getConfiguredSendProtocolMessagesOfType(type).isEmpty();
-    }
-
-    public boolean actuallyReceivedTypeBeforeType(ProtocolMessageType before, ProtocolMessageType after) {
-        for (TLSAction action : tlsActions) {
-            if (action instanceof ReceiveAction) {
-                ReceiveAction receiveAction = (ReceiveAction) action;
-                for (ProtocolMessage message : receiveAction.getActualMessages()) {
-                    if (message.getProtocolMessageType() == before) {
-                        return true;
-                    }
-                    if (message.getProtocolMessageType() == after) {
-                        return false;
-                    }
-                }
-            }
-        }
-        return false;
-    }
-
-    public boolean actuallyReceivedTypeBeforeType(ProtocolMessageType before, HandshakeMessageType after) {
-        for (TLSAction action : tlsActions) {
-            if (action instanceof ReceiveAction) {
-                ReceiveAction receiveAction = (ReceiveAction) action;
-                for (ProtocolMessage message : receiveAction.getActualMessages()) {
-                    if (message.getProtocolMessageType() == before) {
-                        return true;
-                    }
-                    if (message.isHandshakeMessage()) {
-                        HandshakeMessage handshakeMessage = (HandshakeMessage) message;
-                        if (handshakeMessage.getHandshakeMessageType() == after) {
-                            return false;
-                        }
-                    }
-                }
-            }
-        }
-        return false;
+    public boolean containsReceivedProtocolMessage(ProtocolMessageType type) {
+        return !getRecievedProtocolMessagesOfType(type).isEmpty();
     }
 
-    public boolean configuredLooksLikeActual() {
-        for (TLSAction action : tlsActions) {
-            if (action instanceof MessageAction) {
-                MessageAction messageAction = (MessageAction) action;
-                if (!messageAction.configuredLooksLikeActual()) {
-                    return false;
-                }
-            }
-        }
-        return true;
+    public boolean containsSendProtocolMessage(ProtocolMessageType type) {
+        return !getSendProtocolMessagesOfType(type).isEmpty();
     }
-
-    public SendAction getFirstConfiguredSendActionWithType(ProtocolMessageType type) {
+    
+    public SendAction getFirstSendActionWithType(ProtocolMessageType type) {
         for (TLSAction action : tlsActions) {
             if (action instanceof SendAction) {
                 SendAction sendAction = (SendAction) action;
-                for (ProtocolMessage message : sendAction.getConfiguredMessages()) {
+                for (ProtocolMessage message : sendAction.getMessages()) {
                     if (message.getProtocolMessageType() == type) {
                         return sendAction;
                     }
@@ -471,11 +349,11 @@ public class WorkflowTrace implements Serializable {
         return null;
     }
 
-    public SendAction getFirstConfiguredSendActionWithType(HandshakeMessageType type) {
+    public SendAction getFirstSendActionWithType(HandshakeMessageType type) {
         for (TLSAction action : tlsActions) {
             if (action instanceof SendAction) {
                 SendAction sendAction = (SendAction) action;
-                List<HandshakeMessage> messages = filterHandshakeMessagesFromList(sendAction.getConfiguredMessages());
+                List<HandshakeMessage> messages = filterHandshakeMessagesFromList(sendAction.getMessages());
                 if (!filterMessageList(messages, type).isEmpty()) {
                     return sendAction;
                 }
@@ -531,4 +409,4 @@ public class WorkflowTrace implements Serializable {
         }
         return Objects.equals(this.tlsActions, other.tlsActions);
     }
-}
+}
\ No newline at end of file
diff --git a/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeCipherSuiteAction.java b/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeCipherSuiteAction.java
index bd6fdbf8..7f977a28 100644
--- a/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeCipherSuiteAction.java
+++ b/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeCipherSuiteAction.java
@@ -47,7 +47,7 @@ public class ChangeCipherSuiteAction extends TLSAction {
     }
 
     @Override
-    public void execute(TlsContext tlsContext, ActionExecutor executor) throws WorkflowExecutionException {
+    public void execute(TlsContext tlsContext) throws WorkflowExecutionException {
         if (isExecuted()) {
             throw new WorkflowExecutionException("Action already executed!");
         }
diff --git a/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeClientCertificateAction.java b/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeClientCertificateAction.java
index d9c039c8..3dd84a88 100644
--- a/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeClientCertificateAction.java
+++ b/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeClientCertificateAction.java
@@ -43,7 +43,7 @@ public class ChangeClientCertificateAction extends TLSAction {
     }
 
     @Override
-    public void execute(TlsContext tlsContext, ActionExecutor executor) throws WorkflowExecutionException {
+    public void execute(TlsContext tlsContext) throws WorkflowExecutionException {
         if (isExecuted()) {
             throw new WorkflowExecutionException("Action already executed!");
         }
diff --git a/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeClientRandomAction.java b/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeClientRandomAction.java
index bb8a93df..1a615ef9 100644
--- a/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeClientRandomAction.java
+++ b/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeClientRandomAction.java
@@ -48,7 +48,7 @@ public class ChangeClientRandomAction extends TLSAction {
     }
 
     @Override
-    public void execute(TlsContext tlsContext, ActionExecutor executor) throws WorkflowExecutionException {
+    public void execute(TlsContext tlsContext) throws WorkflowExecutionException {
         if (isExecuted()) {
             throw new WorkflowExecutionException("Action already executed!");
         }
diff --git a/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeCompressionAction.java b/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeCompressionAction.java
index 952dadd6..f4ee1a7c 100644
--- a/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeCompressionAction.java
+++ b/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeCompressionAction.java
@@ -44,7 +44,7 @@ public class ChangeCompressionAction extends TLSAction {
     }
 
     @Override
-    public void execute(TlsContext tlsContext, ActionExecutor executor) throws WorkflowExecutionException {
+    public void execute(TlsContext tlsContext) throws WorkflowExecutionException {
         if (isExecuted()) {
             throw new WorkflowExecutionException("Action already executed!");
         }
diff --git a/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeMasterSecretAction.java b/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeMasterSecretAction.java
index 245e14fb..35e06b61 100644
--- a/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeMasterSecretAction.java
+++ b/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeMasterSecretAction.java
@@ -49,7 +49,7 @@ public class ChangeMasterSecretAction extends TLSAction {
     }
 
     @Override
-    public void execute(TlsContext tlsContext, ActionExecutor executor) throws WorkflowExecutionException {
+    public void execute(TlsContext tlsContext) throws WorkflowExecutionException {
         if (isExecuted()) {
             throw new WorkflowExecutionException("Action already executed!");
         }
diff --git a/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/ChangePreMasterSecretAction.java b/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/ChangePreMasterSecretAction.java
index 4cf4b94a..465066bf 100644
--- a/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/ChangePreMasterSecretAction.java
+++ b/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/ChangePreMasterSecretAction.java
@@ -48,7 +48,7 @@ public class ChangePreMasterSecretAction extends TLSAction {
     }
 
     @Override
-    public void execute(TlsContext tlsContext, ActionExecutor executor) throws WorkflowExecutionException {
+    public void execute(TlsContext tlsContext) throws WorkflowExecutionException {
         if (isExecuted()) {
             throw new WorkflowExecutionException("Action already executed!");
         }
diff --git a/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeProtocolVersionAction.java b/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeProtocolVersionAction.java
index 2965e76b..cfb17991 100644
--- a/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeProtocolVersionAction.java
+++ b/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeProtocolVersionAction.java
@@ -44,7 +44,7 @@ public class ChangeProtocolVersionAction extends TLSAction {
     }
 
     @Override
-    public void execute(TlsContext tlsContext, ActionExecutor executor) throws WorkflowExecutionException {
+    public void execute(TlsContext tlsContext) throws WorkflowExecutionException {
         if (isExecuted()) {
             throw new WorkflowExecutionException("Action already executed!");
         }
diff --git a/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeServerCertificateAction.java b/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeServerCertificateAction.java
index aeb0390c..bff90fd9 100644
--- a/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeServerCertificateAction.java
+++ b/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeServerCertificateAction.java
@@ -45,7 +45,7 @@ public class ChangeServerCertificateAction extends TLSAction {
     }
 
     @Override
-    public void execute(TlsContext tlsContext, ActionExecutor executor) throws WorkflowExecutionException {
+    public void execute(TlsContext tlsContext) throws WorkflowExecutionException {
         if (isExecuted()) {
             throw new WorkflowExecutionException("Action already executed!");
         }
diff --git a/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeServerRandomAction.java b/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeServerRandomAction.java
index 2914c668..1f453b69 100644
--- a/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeServerRandomAction.java
+++ b/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeServerRandomAction.java
@@ -49,7 +49,7 @@ public class ChangeServerRandomAction extends TLSAction {
     }
 
     @Override
-    public void execute(TlsContext tlsContext, ActionExecutor executor) throws WorkflowExecutionException {
+    public void execute(TlsContext tlsContext) throws WorkflowExecutionException {
         if (isExecuted()) {
             throw new WorkflowExecutionException("Action already executed!");
         }
diff --git a/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/DeactivateEncryptionAction.java b/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/DeactivateEncryptionAction.java
index c4a2c65d..3b827fef 100644
--- a/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/DeactivateEncryptionAction.java
+++ b/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/DeactivateEncryptionAction.java
@@ -23,7 +23,7 @@ public class DeactivateEncryptionAction extends TLSAction {
     }
 
     @Override
-    public void execute(TlsContext tlsContext, ActionExecutor executor) throws WorkflowExecutionException {
+    public void execute(TlsContext tlsContext) throws WorkflowExecutionException {
         if (isExecuted()) {
             throw new WorkflowExecutionException("Action already executed!");
         }
diff --git a/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/MessageAction.java b/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/MessageAction.java
index 6cefb82d..687721d0 100644
--- a/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/MessageAction.java
+++ b/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/MessageAction.java
@@ -51,135 +51,98 @@ import javax.xml.bind.annotation.XmlElements;
 public abstract class MessageAction extends TLSAction {
 
     @XmlElementWrapper
-    @XmlElements(value = { @XmlElement(type = ProtocolMessage.class, name = "ProtocolMessage"),
-            @XmlElement(type = ArbitraryMessage.class, name = "ArbitraryMessage"),
-            @XmlElement(type = CertificateMessage.class, name = "Certificate"),
-            @XmlElement(type = CertificateVerifyMessage.class, name = "CertificateVerify"),
-            @XmlElement(type = CertificateRequestMessage.class, name = "CertificateRequest"),
-            @XmlElement(type = ClientHelloMessage.class, name = "ClientHello"),
-            @XmlElement(type = HelloVerifyRequestMessage.class, name = "HelloVerifyRequest"),
-            @XmlElement(type = DHClientKeyExchangeMessage.class, name = "DHClientKeyExchange"),
-            @XmlElement(type = DHEServerKeyExchangeMessage.class, name = "DHEServerKeyExchange"),
-            @XmlElement(type = ECDHClientKeyExchangeMessage.class, name = "ECDHClientKeyExchange"),
-            @XmlElement(type = ECDHEServerKeyExchangeMessage.class, name = "ECDHEServerKeyExchange"),
-            @XmlElement(type = FinishedMessage.class, name = "Finished"),
-            @XmlElement(type = RSAClientKeyExchangeMessage.class, name = "RSAClientKeyExchange"),
-            @XmlElement(type = ServerHelloDoneMessage.class, name = "ServerHelloDone"),
-            @XmlElement(type = ServerHelloMessage.class, name = "ServerHello"),
-            @XmlElement(type = AlertMessage.class, name = "Alert"),
-            @XmlElement(type = ApplicationMessage.class, name = "Application"),
-            @XmlElement(type = ChangeCipherSpecMessage.class, name = "ChangeCipherSpec"),
-            @XmlElement(type = SSL2ClientHelloMessage.class, name = "SSL2ClientHello"),
-            @XmlElement(type = SSL2ServerHelloMessage.class, name = "SSL2ServerHello"),
-            @XmlElement(type = UnknownMessage.class, name = "UnknownMessage"),
-            @XmlElement(type = UnknownHandshakeMessage.class, name = "UnknownHandshakeMessage"),
-            @XmlElement(type = RetransmitMessage.class, name = "RetransmitMessage"),
-            @XmlElement(type = HelloRequestMessage.class, name = "HelloRequest"),
-            @XmlElement(type = HeartbeatMessage.class, name = "Heartbeat") })
+    @XmlElements(value = {
+        @XmlElement(type = ProtocolMessage.class, name = "ProtocolMessage")
+        ,
+            @XmlElement(type = ArbitraryMessage.class, name = "ArbitraryMessage")
+        ,
+            @XmlElement(type = CertificateMessage.class, name = "Certificate")
+        ,
+            @XmlElement(type = CertificateVerifyMessage.class, name = "CertificateVerify")
+        ,
+            @XmlElement(type = CertificateRequestMessage.class, name = "CertificateRequest")
+        ,
+            @XmlElement(type = ClientHelloMessage.class, name = "ClientHello")
+        ,
+            @XmlElement(type = HelloVerifyRequestMessage.class, name = "HelloVerifyRequest")
+        ,
+            @XmlElement(type = DHClientKeyExchangeMessage.class, name = "DHClientKeyExchange")
+        ,
+            @XmlElement(type = DHEServerKeyExchangeMessage.class, name = "DHEServerKeyExchange")
+        ,
+            @XmlElement(type = ECDHClientKeyExchangeMessage.class, name = "ECDHClientKeyExchange")
+        ,
+            @XmlElement(type = ECDHEServerKeyExchangeMessage.class, name = "ECDHEServerKeyExchange")
+        ,
+            @XmlElement(type = FinishedMessage.class, name = "Finished")
+        ,
+            @XmlElement(type = RSAClientKeyExchangeMessage.class, name = "RSAClientKeyExchange")
+        ,
+            @XmlElement(type = ServerHelloDoneMessage.class, name = "ServerHelloDone")
+        ,
+            @XmlElement(type = ServerHelloMessage.class, name = "ServerHello")
+        ,
+            @XmlElement(type = AlertMessage.class, name = "Alert")
+        ,
+            @XmlElement(type = ApplicationMessage.class, name = "Application")
+        ,
+            @XmlElement(type = ChangeCipherSpecMessage.class, name = "ChangeCipherSpec")
+        ,
+            @XmlElement(type = SSL2ClientHelloMessage.class, name = "SSL2ClientHello")
+        ,
+            @XmlElement(type = SSL2ServerHelloMessage.class, name = "SSL2ServerHello")
+        ,
+            @XmlElement(type = UnknownMessage.class, name = "UnknownMessage")
+        ,
+            @XmlElement(type = UnknownHandshakeMessage.class, name = "UnknownHandshakeMessage")
+        ,
+            @XmlElement(type = RetransmitMessage.class, name = "RetransmitMessage")
+        ,
+            @XmlElement(type = HelloRequestMessage.class, name = "HelloRequest")
+        ,
+            @XmlElement(type = HeartbeatMessage.class, name = "Heartbeat")})
     @HoldsModifiableVariable
-    protected List<ProtocolMessage> configuredMessages;
-    @XmlElementWrapper
-    @XmlElements(value = { @XmlElement(type = ProtocolMessage.class, name = "ProtocolMessage"),
-            @XmlElement(type = ArbitraryMessage.class, name = "ArbitraryMessage"),
-            @XmlElement(type = CertificateMessage.class, name = "Certificate"),
-            @XmlElement(type = CertificateVerifyMessage.class, name = "CertificateVerify"),
-            @XmlElement(type = CertificateRequestMessage.class, name = "CertificateRequest"),
-            @XmlElement(type = ClientHelloMessage.class, name = "ClientHello"),
-            @XmlElement(type = HelloVerifyRequestMessage.class, name = "HelloVerifyRequest"),
-            @XmlElement(type = DHClientKeyExchangeMessage.class, name = "DHClientKeyExchange"),
-            @XmlElement(type = DHEServerKeyExchangeMessage.class, name = "DHEServerKeyExchange"),
-            @XmlElement(type = ECDHClientKeyExchangeMessage.class, name = "ECDHClientKeyExchange"),
-            @XmlElement(type = ECDHEServerKeyExchangeMessage.class, name = "ECDHEServerKeyExchange"),
-            @XmlElement(type = FinishedMessage.class, name = "Finished"),
-            @XmlElement(type = RSAClientKeyExchangeMessage.class, name = "RSAClientKeyExchange"),
-            @XmlElement(type = ServerHelloDoneMessage.class, name = "ServerHelloDone"),
-            @XmlElement(type = ServerHelloMessage.class, name = "ServerHello"),
-            @XmlElement(type = AlertMessage.class, name = "Alert"),
-            @XmlElement(type = ApplicationMessage.class, name = "Application"),
-            @XmlElement(type = ChangeCipherSpecMessage.class, name = "ChangeCipherSpec"),
-            @XmlElement(type = SSL2ClientHelloMessage.class, name = "SSL2ClientHello"),
-            @XmlElement(type = SSL2ServerHelloMessage.class, name = "SSL2ServerHello"),
-            @XmlElement(type = UnknownMessage.class, name = "UnknownMessage"),
-            @XmlElement(type = UnknownHandshakeMessage.class, name = "UnknownHandshakeMessage"),
-            @XmlElement(type = RetransmitMessage.class, name = "RetransmitMessage"),
-            @XmlElement(type = HelloRequestMessage.class, name = "HelloRequest"),
-            @XmlElement(type = HeartbeatMessage.class, name = "Heartbeat") })
-    protected List<ProtocolMessage> actualMessages;
+    protected List<ProtocolMessage> messages;
 
     @HoldsModifiableVariable
     @XmlElementWrapper
-    @XmlElements(value = { @XmlElement(type = Record.class, name = "Record"),
-            @XmlElement(type = BlobRecord.class, name = "BlobRecord") })
-    protected List<AbstractRecord> configuredRecords;
-
-    @HoldsModifiableVariable
-    @XmlElementWrapper
-    @XmlElements(value = { @XmlElement(type = Record.class, name = "Record"),
-            @XmlElement(type = BlobRecord.class, name = "BlobRecord") })
-    protected List<AbstractRecord> actualRecords;
+    @XmlElements(value = {
+        @XmlElement(type = Record.class, name = "Record")
+        ,
+            @XmlElement(type = BlobRecord.class, name = "BlobRecord")})
+    protected List<AbstractRecord> records;
 
     public MessageAction(List<ProtocolMessage> messages) {
-        this.configuredMessages = messages;
-        actualMessages = new LinkedList<>();
-        actualRecords = new LinkedList<>();
-        this.configuredRecords = null;
+        this.messages = messages;
+        this.records = new LinkedList<>();
     }
 
-    public List<AbstractRecord> getConfiguredRecords() {
-        return configuredRecords;
+    public List<AbstractRecord> getRecords() {
+        return records;
     }
 
-    public void setConfiguredRecords(List<AbstractRecord> configuredRecords) {
-        this.configuredRecords = configuredRecords;
+    public void setRecords(List<AbstractRecord> records) {
+        this.records = records;
     }
 
-    public List<AbstractRecord> getActualRecords() {
-        return actualRecords;
+    public List<ProtocolMessage> getMessages() {
+        return messages;
     }
 
-    public List<ProtocolMessage> getActualMessages() {
-        return actualMessages;
-    }
-
-    public List<ProtocolMessage> getConfiguredMessages() {
-        return configuredMessages;
-    }
-
-    public void setConfiguredMessages(List<ProtocolMessage> configuredMessages) {
-        this.configuredMessages = configuredMessages;
-    }
-
-    /**
-     * Checks that every configured message also appears in the actual messages
-     * and no additional messages are present
-     *
-     * @return
-     */
-    public boolean configuredLooksLikeActual() {
-        if (actualMessages.size() != configuredMessages.size()) {
-            return false;
-        } else {
-            for (int i = 0; i < actualMessages.size(); i++) {
-                if (!actualMessages.get(i).getClass().equals(configuredMessages.get(i).getClass())) {
-                    return false;
-                }
-            }
-        }
-        return true;
+    public void setMessages(List<ProtocolMessage> messages) {
+        this.messages = messages;
     }
 
     @Override
     public void reset() {
         setExecuted(null);
-        actualMessages = new LinkedList<>();
-        actualRecords = new LinkedList<>();
     }
 
     @Override
     public int hashCode() {
         int hash = 3;
-        hash = 97 * hash + Objects.hashCode(this.configuredMessages);
-        hash = 97 * hash + Objects.hashCode(this.actualMessages);
+        hash = 97 * hash + Objects.hashCode(this.messages);
+        hash = 97 * hash + Objects.hashCode(this.records);
         return hash;
     }
 
@@ -195,10 +158,13 @@ public abstract class MessageAction extends TLSAction {
             return false;
         }
         final MessageAction other = (MessageAction) obj;
-        if (!Objects.equals(this.configuredMessages, other.configuredMessages)) {
+        if (!Objects.equals(this.messages, other.messages)) {
+            return false;
+        }
+        if (!Objects.equals(this.records, other.records)) {
             return false;
         }
-        return Objects.equals(this.actualMessages, other.actualMessages);
+        return true;
     }
 
     public String getReadableString(List<ProtocolMessage> messages) {
diff --git a/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/MessageActionFactory.java b/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/MessageActionFactory.java
index 3ee31b73..5f4d030c 100644
--- a/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/MessageActionFactory.java
+++ b/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/MessageActionFactory.java
@@ -26,7 +26,7 @@ public class MessageActionFactory {
         if (myConnectionEndType == sendingConnectionEndType) {
             return new SendAction(messages);
         } else {
-            return new ReceiveAction(messages);
+            return new FastReceiveAction(messages);
         }
 
     }
@@ -36,7 +36,7 @@ public class MessageActionFactory {
         if (myConnectionEnd == sendingConnectionEnd) {
             return new SendAction(protocolMessages);
         } else {
-            return new ReceiveAction(protocolMessages);
+            return new FastReceiveAction(protocolMessages);
         }
 
     }
diff --git a/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/ReceiveAction.java b/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/ReceiveAction.java
index dc7ee37a..46f682f7 100644
--- a/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/ReceiveAction.java
+++ b/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/ReceiveAction.java
@@ -8,20 +8,31 @@
  */
 package de.rub.nds.tlsattacker.core.workflow.action;
 
-import de.rub.nds.tlsattacker.core.exceptions.WorkflowExecutionException;
+import de.rub.nds.tlsattacker.core.constants.HandshakeMessageType;
+import de.rub.nds.tlsattacker.core.constants.ProtocolMessageType;
+import de.rub.nds.tlsattacker.core.exceptions.AdjustmentException;
+import de.rub.nds.tlsattacker.core.exceptions.ParserException;
+import de.rub.nds.tlsattacker.core.protocol.handler.ParserResult;
+import de.rub.nds.tlsattacker.core.protocol.handler.ProtocolMessageHandler;
+import de.rub.nds.tlsattacker.core.protocol.handler.factory.HandlerFactory;
 import de.rub.nds.tlsattacker.core.protocol.message.ProtocolMessage;
+import de.rub.nds.tlsattacker.core.record.AbstractRecord;
 import de.rub.nds.tlsattacker.core.workflow.TlsContext;
 import static de.rub.nds.tlsattacker.core.workflow.action.TLSAction.LOGGER;
-import de.rub.nds.tlsattacker.core.workflow.action.executor.ActionExecutor;
-import de.rub.nds.tlsattacker.core.workflow.action.executor.MessageActionResult;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
 import java.util.LinkedList;
 import java.util.List;
+import javax.xml.bind.annotation.XmlTransient;
 
 /**
  *
  * @author Robert Merget - robert.merget@rub.de
  */
-public class ReceiveAction extends MessageAction {
+public abstract class ReceiveAction extends MessageAction {
+
+    @XmlTransient
+    protected TlsContext context = null;
 
     public ReceiveAction() {
         super(new LinkedList<ProtocolMessage>());
@@ -33,41 +44,126 @@ public class ReceiveAction extends MessageAction {
 
     public ReceiveAction(ProtocolMessage message) {
         super(new LinkedList<ProtocolMessage>());
-        configuredMessages.add(message);
+        messages.add(message);
+    }
+
+    protected byte[] receiveByteArray() throws IOException {
+        return context.getTransportHandler().fetchData();
     }
 
-    @Override
-    public void execute(TlsContext tlsContext, ActionExecutor executor) {
-        if (isExecuted()) {
-            throw new WorkflowExecutionException("Action already executed!");
+    protected List<AbstractRecord> parseRecords(byte[] recordBytes) {
+        List<AbstractRecord> receivedRecords = context.getRecordLayer().parseRecords(recordBytes);
+        return receivedRecords;
+    }
+
+    protected List<ProtocolMessage> parseMessages(List<AbstractRecord> records) {
+        if (records.isEmpty()) {
+            return new LinkedList<>();
         }
-        LOGGER.info("Receiving Messages...");
-        MessageActionResult result = executor.receiveMessages(configuredMessages);
-        actualRecords.addAll(result.getRecordList());
-        actualMessages.addAll(result.getMessageList());
-        setExecuted(true);
-
-        String expected = getReadableString(configuredMessages);
-        LOGGER.debug("Receive Expected:" + expected);
-        String received = getReadableString(actualMessages);
-        LOGGER.debug("Receive Actual:" + received);
-        LOGGER.info("Received Messages:" + received);
+        byte[] cleanProtocolMessageBytes = getCleanBytes(records);
+        return recieveMessage(cleanProtocolMessageBytes, getProtocolMessageType(records));
     }
 
-    @Override
-    public String toString() {
-        StringBuilder sb = new StringBuilder("Receive Action:\n");
-        sb.append("\tConfigured:");
-        for (ProtocolMessage message : configuredMessages) {
-            sb.append(message.toCompactString());
-            sb.append(", ");
+    protected List<ProtocolMessage> recieveMessage(byte[] cleanProtocolMessageBytes, ProtocolMessageType typeFromRecord) {
+        int dataPointer = 0;
+        List<ProtocolMessage> receivedMessages = new LinkedList<>();
+        while (dataPointer < cleanProtocolMessageBytes.length) {
+            ParserResult result = null;
+            try {
+                HandshakeMessageType handshakeMessageType = HandshakeMessageType
+                        .getMessageType(cleanProtocolMessageBytes[dataPointer]);
+                ProtocolMessageHandler pmh = HandlerFactory.getHandler(context, typeFromRecord, handshakeMessageType);
+                result = pmh.parseMessage(cleanProtocolMessageBytes, dataPointer);
+            } catch (ParserException | AdjustmentException E) {
+                LOGGER.warn("Could not parse Message as a CorrectMessage, parsing as UnknownHandshakeMessage instead!");
+                LOGGER.debug(E);
+                // Parsing as the specified Message did not work, try parsing it
+                // as an Unknown message
+                try {
+                    if (typeFromRecord == ProtocolMessageType.HANDSHAKE) {
+                        HandshakeMessageType handshakeType = HandshakeMessageType.UNKNOWN;
+                        ProtocolMessageHandler pmh = HandlerFactory.getHandler(context, typeFromRecord, handshakeType);
+                        result = pmh.parseMessage(cleanProtocolMessageBytes, dataPointer);
+                    }
+                } catch (ParserException ex) {
+                    LOGGER.warn("Could not parse Message as UnknownHandshakeMessage, parsing as UnknownMessage instead!");
+                    LOGGER.debug(ex);
+                } finally {
+                    if (result == null) {
+                        ProtocolMessageHandler pmh = HandlerFactory.getHandler(context, ProtocolMessageType.UNKNOWN,
+                                null);
+                        result = pmh.parseMessage(cleanProtocolMessageBytes, dataPointer);
+                    }
+                }
+            }
+            dataPointer = result.getParserPosition();
+            LOGGER.debug("The following message was parsed: {}", result.getMessage().toString());
+            receivedMessages.add(result.getMessage());
         }
-        sb.append("\n\tActual:");
-        for (ProtocolMessage message : actualMessages) {
-            sb.append(message.toCompactString());
-            sb.append(", ");
+        return receivedMessages;
+    }
+
+    protected byte[] getCleanBytes(List<AbstractRecord> recordSubGroup) {
+        ByteArrayOutputStream stream = new ByteArrayOutputStream();
+        for (AbstractRecord record : recordSubGroup) {
+            try {
+                stream.write(record.getCleanProtocolMessageBytes().getValue());
+            } catch (IOException ex) {
+                LOGGER.warn("Could not write CleanProtocolMessage bytes to Array");
+                LOGGER.debug(ex);
+            }
         }
-        return sb.toString();
+        return stream.toByteArray();
     }
 
+    protected List<List<AbstractRecord>> getRecordGroups(List<AbstractRecord> records) {
+        List<List<AbstractRecord>> returnList = new LinkedList<>();
+        if (records.isEmpty()) {
+            return returnList;
+        }
+        List<AbstractRecord> subGroup = new LinkedList<>();
+        ProtocolMessageType currentSearchType = records.get(0).getContentMessageType();
+        for (AbstractRecord record : records) {
+            if (record.getContentMessageType() == currentSearchType) {
+                subGroup.add(record);
+            } else {
+                returnList.add(subGroup);
+                subGroup = new LinkedList<>();
+                currentSearchType = record.getContentMessageType();
+                subGroup.add(record);
+            }
+        }
+        returnList.add(subGroup);
+        return returnList;
+
+    }
+
+    protected ProtocolMessageType getProtocolMessageType(List<AbstractRecord> recordSubGroup) {
+        ProtocolMessageType type = null;
+        for (AbstractRecord record : recordSubGroup) {
+            if (type == null) {
+                type = record.getContentMessageType();
+            } else {
+                ProtocolMessageType tempType = ProtocolMessageType.getContentType(record.getContentMessageType()
+                        .getValue());
+                if (tempType != type) {
+                    LOGGER.error("Mixed Subgroup detected");
+                }
+            }
+
+        }
+        return type;
+    }
+
+    protected void decryptRecords(List<AbstractRecord> records) {
+        for (AbstractRecord record : records) {
+            context.getRecordLayer().decryptRecord(record);
+        }
+    }
+
+    protected void adjustContext(List<AbstractRecord> recordGroup) {
+        for (AbstractRecord record : recordGroup) {
+            record.adjustContext(context);
+        }
+    }
 }
diff --git a/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/RenegotiationAction.java b/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/RenegotiationAction.java
index 7f34a002..32da43f1 100644
--- a/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/RenegotiationAction.java
+++ b/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/RenegotiationAction.java
@@ -20,7 +20,7 @@ import java.io.IOException;
 public class RenegotiationAction extends TLSAction {
 
     @Override
-    public void execute(TlsContext tlsContext, ActionExecutor executor) throws WorkflowExecutionException, IOException {
+    public void execute(TlsContext tlsContext) throws WorkflowExecutionException, IOException {
         if (isExecuted()) {
             throw new WorkflowExecutionException("Action already executed!");
         }
diff --git a/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/ResetConnectionAction.java b/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/ResetConnectionAction.java
index 9b151989..c1b9a12b 100644
--- a/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/ResetConnectionAction.java
+++ b/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/ResetConnectionAction.java
@@ -23,7 +23,7 @@ public class ResetConnectionAction extends TLSAction {
     }
 
     @Override
-    public void execute(TlsContext tlsContext, ActionExecutor executor) throws WorkflowExecutionException, IOException {
+    public void execute(TlsContext tlsContext) throws WorkflowExecutionException, IOException {
         LOGGER.info("Terminating Connection");
         tlsContext.getTransportHandler().closeConnection();
         LOGGER.info("Reopening Connection");
diff --git a/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/SendAction.java b/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/SendAction.java
index 0435853b..6c61fb38 100644
--- a/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/SendAction.java
+++ b/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/SendAction.java
@@ -8,13 +8,17 @@
  */
 package de.rub.nds.tlsattacker.core.workflow.action;
 
+import de.rub.nds.tlsattacker.core.constants.ProtocolMessageType;
 import de.rub.nds.tlsattacker.core.exceptions.WorkflowExecutionException;
+import de.rub.nds.tlsattacker.core.protocol.handler.ProtocolMessageHandler;
 import de.rub.nds.tlsattacker.core.protocol.message.ProtocolMessage;
+import de.rub.nds.tlsattacker.core.record.AbstractRecord;
 import de.rub.nds.tlsattacker.core.workflow.TlsContext;
-import de.rub.nds.tlsattacker.core.workflow.action.executor.ActionExecutor;
-import de.rub.nds.tlsattacker.core.workflow.action.executor.MessageActionResult;
+import de.rub.nds.tlsattacker.core.workflow.action.executor.MessageBytesCollector;
+import java.io.IOException;
 import java.util.LinkedList;
 import java.util.List;
+import javax.xml.bind.annotation.XmlTransient;
 
 /**
  * todo print configured records
@@ -23,6 +27,9 @@ import java.util.List;
  */
 public class SendAction extends MessageAction {
 
+    @XmlTransient
+    private TlsContext context;
+    
     public SendAction() {
         super(new LinkedList<ProtocolMessage>());
     }
@@ -33,36 +40,124 @@ public class SendAction extends MessageAction {
 
     public SendAction(ProtocolMessage message) {
         super(new LinkedList<ProtocolMessage>());
-        configuredMessages.add(message);
+        messages.add(message);
     }
 
     @Override
-    public void execute(TlsContext tlsContext, ActionExecutor executor) {
+    public void execute(TlsContext context) {
+        this.context = context;
         if (isExecuted()) {
             throw new WorkflowExecutionException("Action already executed!");
         }
-        LOGGER.info("Sending " + getReadableString(configuredMessages));
-        MessageActionResult result = executor.sendMessages(configuredMessages, configuredRecords);
-        actualMessages.addAll(result.getMessageList());
-        actualRecords.addAll(result.getRecordList());
-
-        String expected = getReadableString(configuredMessages);
-        LOGGER.debug("Send Expected:" + expected);
-        String received = getReadableString(actualMessages);
-        LOGGER.debug("Send Actual:" + received);
+        LOGGER.info("Sending " + getReadableString(messages));
+        sendMessages(context);
         setExecuted(true);
     }
+    
+    public void sendMessages(TlsContext context) {
+        context.setTalkingConnectionEndType(context.getConfig().getConnectionEndType());
+        if (records == null) {
+            records = new LinkedList<>();
+        }
+        int recordPosition = 0;
+        ProtocolMessageType lastType = null;
+        MessageBytesCollector messageBytesCollector = new MessageBytesCollector();
+        for (ProtocolMessage message : messages) {
+            if (message.getProtocolMessageType() != lastType && lastType != null
+                    && context.getConfig().isFlushOnMessageTypeChange()) {
+                recordPosition = flushBytesToRecords(messageBytesCollector, lastType, records, recordPosition);
+                if (lastType == ProtocolMessageType.CHANGE_CIPHER_SPEC) {
+                    // TODO this should not be here
+                    context.getRecordLayer().updateEncryptionCipher();
+                }
+            }
+            lastType = message.getProtocolMessageType();
+            LOGGER.debug("Preparing " + message.toCompactString());
+            byte[] protocolMessageBytes = prepareProtocolMessageBytes(message);
+            if (message.isGoingToBeSent()) {
+                messageBytesCollector.appendProtocolMessageBytes(protocolMessageBytes);
+            }
+            if (context.getConfig().isCreateIndividualRecords()) {
+                recordPosition = flushBytesToRecords(messageBytesCollector, lastType, records, recordPosition);
+            }
+        }
+        flushBytesToRecords(messageBytesCollector, lastType, records, recordPosition);
+        try {
+            sendData(messageBytesCollector);
+        } catch (IOException ex) {
+            ex.printStackTrace();
+        }
+    }
+    /**
+     * Chooses the correct handler for the ProtocolMessage and returns the
+     * preparedMessage bytes
+     *
+     * @param message
+     *            Message to prepare
+     * @return Prepared message bytes for the ProtocolMessage
+     */
+    private byte[] prepareProtocolMessageBytes(ProtocolMessage message) {
+        LOGGER.debug("Preparing the following protocol message to send: {}", message.toCompactString());
+        ProtocolMessageHandler handler = message.getHandler(context);
+        byte[] protocolMessageBytes = handler.prepareMessage(message);
+        return protocolMessageBytes;
+    }
+    
+    /**
+     * Sends all messageBytes in the MessageByteCollector with the specified
+     * TransportHandler
+     *
+     * @param handler
+     *            TransportHandler to send the Data with
+     * @param messageBytesCollector
+     *            MessageBytes to send
+     * @throws IOException
+     *             Thrown if something goes wrong while sending
+     */
+    private void sendData(MessageBytesCollector collector) throws IOException {
+        context.getTransportHandler().sendData(collector.getRecordBytes());
+        collector.flushRecordBytes();
+    }
 
+    private int flushBytesToRecords(MessageBytesCollector collector, ProtocolMessageType type,
+            List<AbstractRecord> records, int recordPosition) {
+        int length = collector.getProtocolMessageBytesStream().length;
+        List<AbstractRecord> toFillList = getEnoughRecords(length, recordPosition, records);
+        collector.appendRecordBytes(context.getRecordLayer().prepareRecords(collector.getProtocolMessageBytesStream(),
+                type, toFillList));
+        collector.flushProtocolMessageBytes();
+        return recordPosition + toFillList.size();
+    }
+    
+    
+    private List<AbstractRecord> getEnoughRecords(int length, int position, List<AbstractRecord> records) {
+        List<AbstractRecord> toFillList = new LinkedList<>();
+        int recordLength = 0;
+        while (recordLength < length) {
+            if (position >= records.size()) {
+                if (context.getConfig().isCreateRecordsDynamically()) {
+                    records.add(context.getRecordLayer().getFreshRecord());
+                } else {
+                    return toFillList;
+                }
+            }
+            AbstractRecord record = records.get(position);
+            toFillList.add(record);
+            if (record.getMaxRecordLengthConfig() == null) {
+                record.setMaxRecordLengthConfig(context.getConfig().getDefaultMaxRecordData());
+            }
+            recordLength += record.getMaxRecordLengthConfig();
+            position++;
+        }
+        return toFillList;
+    }
+
+    
     @Override
     public String toString() {
         StringBuilder sb = new StringBuilder("Send Action:\n");
-        sb.append("\tConfigured:");
-        for (ProtocolMessage message : configuredMessages) {
-            sb.append(message.toCompactString());
-            sb.append(", ");
-        }
-        sb.append("\n\tActual:");
-        for (ProtocolMessage message : actualMessages) {
+        sb.append("\tMessages:");
+        for (ProtocolMessage message : messages) {
             sb.append(message.toCompactString());
             sb.append(", ");
         }
diff --git a/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/TLSAction.java b/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/TLSAction.java
index 8e2e04a2..b8fac881 100644
--- a/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/TLSAction.java
+++ b/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/TLSAction.java
@@ -28,9 +28,9 @@ public abstract class TLSAction implements Serializable {
     protected static final Logger LOGGER = LogManager.getLogger(TLSAction.class.getName());
 
     private static final boolean EXECUTED_DEFAULT = false;
-
+    
     private Boolean executed = null;
-
+    
     public boolean isExecuted() {
         if (executed == null) {
             return EXECUTED_DEFAULT;
@@ -42,7 +42,7 @@ public abstract class TLSAction implements Serializable {
         this.executed = executed;
     }
 
-    public abstract void execute(TlsContext tlsContext, ActionExecutor executor) throws WorkflowExecutionException,
+    public abstract void execute(TlsContext tlsContext) throws WorkflowExecutionException,
             IOException;
 
     public boolean isMessageAction() {
diff --git a/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/WaitingAction.java b/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/WaitingAction.java
index 31f63613..9d015d2b 100644
--- a/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/WaitingAction.java
+++ b/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/workflow/action/WaitingAction.java
@@ -31,7 +31,7 @@ public class WaitingAction extends TLSAction {
     }
 
     @Override
-    public void execute(TlsContext tlsContext, ActionExecutor executor) throws WorkflowExecutionException, IOException {
+    public void execute(TlsContext tlsContext) throws WorkflowExecutionException, IOException {
         LOGGER.info("Wating " + time + "ms...");
         try {
             Thread.sleep(time);
diff --git a/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/protocol/parser/SerialisationFullTest.java b/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/protocol/parser/SerialisationFullTest.java
index 194ec660..a06f8985 100644
--- a/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/protocol/parser/SerialisationFullTest.java
+++ b/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/protocol/parser/SerialisationFullTest.java
@@ -137,7 +137,7 @@ public class SerialisationFullTest {
         List<AbstractRecord> records = new LinkedList<>();
         records.add(new BlobRecord());
         records.add(new Record());
-        action.setConfiguredRecords(records);
+        action.setRecords(records);
         trace.add(action);
 
         File f = folder.newFile();
diff --git a/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/protocol/serializer/DHEServerKeyExchangeSerializerTest.java b/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/protocol/serializer/DHEServerKeyExchangeSerializerTest.java
index a8833ee1..5a8b89f1 100644
--- a/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/protocol/serializer/DHEServerKeyExchangeSerializerTest.java
+++ b/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/protocol/serializer/DHEServerKeyExchangeSerializerTest.java
@@ -87,7 +87,7 @@ public class DHEServerKeyExchangeSerializerTest {
         msg.setPublicKeyLength(serializedKeyLength);
         msg.setSignature(signature);
         if (sigAlgo != null) {
-            msg.setSignatureAlgorithm(sigAlgo);
+            msg.setSignatureHashAlgorithm(sigAlgo);
         }
         if (hashAlgo != null) {
             msg.setHashAlgorithm(hashAlgo);
diff --git a/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/protocol/serializer/ECDHEServerKeyExchangeSerializerTest.java b/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/protocol/serializer/ECDHEServerKeyExchangeSerializerTest.java
index bba5acb4..362e3669 100644
--- a/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/protocol/serializer/ECDHEServerKeyExchangeSerializerTest.java
+++ b/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/protocol/serializer/ECDHEServerKeyExchangeSerializerTest.java
@@ -83,7 +83,7 @@ public class ECDHEServerKeyExchangeSerializerTest {
             msg.setHashAlgorithm(hashAlgorithm);
         }
         if (signatureAlgorithm != null) {
-            msg.setSignatureAlgorithm(signatureAlgorithm);
+            msg.setSignatureHashAlgorithm(signatureAlgorithm);
         }
         msg.setSignatureLength(sigLength);
         msg.setSignature(signature);
diff --git a/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/unittest/helper/WorkFlowTraceFakeExecuter.java b/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/unittest/helper/WorkFlowTraceFakeExecuter.java
index 1b684e64..bf50c4db 100644
--- a/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/unittest/helper/WorkFlowTraceFakeExecuter.java
+++ b/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/unittest/helper/WorkFlowTraceFakeExecuter.java
@@ -9,6 +9,7 @@
 package de.rub.nds.tlsattacker.core.unittest.helper;
 
 import de.rub.nds.tlsattacker.core.workflow.WorkflowTrace;
+import de.rub.nds.tlsattacker.core.workflow.action.FastReceiveAction;
 import de.rub.nds.tlsattacker.core.workflow.action.MessageAction;
 import de.rub.nds.tlsattacker.core.workflow.action.TLSAction;
 import java.util.List;
@@ -22,10 +23,10 @@ public class WorkFlowTraceFakeExecuter {
         List<TLSAction> actionList = trace.getTLSActions();
         for (TLSAction action : actionList) {
 
-            if (action instanceof MessageAction) {
-                MessageAction messageAction = (MessageAction) action;
-                messageAction.getActualMessages().clear();
-                messageAction.getActualMessages().addAll(messageAction.getConfiguredMessages());
+            if (action instanceof FastReceiveAction) {
+                FastReceiveAction receiveAction = (FastReceiveAction) action;
+                receiveAction.getMessages().clear();
+                receiveAction.getMessages().addAll(receiveAction.getExpectedMessages());
             }
         }
     }
diff --git a/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/workflow/WorkflowTraceSerializerTest.java b/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/workflow/WorkflowTraceSerializerTest.java
index 8f5eb0c2..19e5e7e5 100644
--- a/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/workflow/WorkflowTraceSerializerTest.java
+++ b/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/workflow/WorkflowTraceSerializerTest.java
@@ -59,7 +59,7 @@ public class WorkflowTraceSerializerTest {
         record.setMaxRecordLengthConfig(5);
         records.add(record);
         SendAction action = new SendAction(new ClientHelloMessage());
-        action.setConfiguredRecords(records);
+        action.setRecords(records);
 
         ByteArrayOutputStream os = new ByteArrayOutputStream();
         WorkflowTraceSerializer.write(os, trace);
diff --git a/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeCipherSuiteActionTest.java b/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeCipherSuiteActionTest.java
index 25113ec4..5d15728c 100644
--- a/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeCipherSuiteActionTest.java
+++ b/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeCipherSuiteActionTest.java
@@ -74,7 +74,7 @@ public class ChangeCipherSuiteActionTest {
      */
     @Test
     public void testGetOldValue() {
-        action.execute(tlsContext, executor);
+        action.execute(tlsContext);
         assertEquals(action.getOldValue(), CipherSuite.TLS_DHE_DSS_WITH_AES_128_CBC_SHA);
     }
 
@@ -83,7 +83,7 @@ public class ChangeCipherSuiteActionTest {
      */
     @Test
     public void testExecute() {
-        action.execute(tlsContext, executor);
+        action.execute(tlsContext);
         assertEquals(tlsContext.getSelectedCipherSuite(), action.getNewValue());
         // TODO check that cipher is reinitialised
         assertTrue(action.isExecuted());
@@ -95,11 +95,11 @@ public class ChangeCipherSuiteActionTest {
     @Test
     public void testReset() {
         assertFalse(action.isExecuted());
-        action.execute(tlsContext, executor);
+        action.execute(tlsContext);
         assertTrue(action.isExecuted());
         action.reset();
         assertFalse(action.isExecuted());
-        action.execute(tlsContext, executor);
+        action.execute(tlsContext);
         assertTrue(action.isExecuted());
     }
 
diff --git a/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeClientCertificateActionTest.java b/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeClientCertificateActionTest.java
index 46dc19ec..e8bb5335 100644
--- a/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeClientCertificateActionTest.java
+++ b/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeClientCertificateActionTest.java
@@ -69,7 +69,7 @@ public class ChangeClientCertificateActionTest {
     @Test
     public void testGetOldValue() {
         tlsContext.setClientCertificate(TestCertificates.getTestCertificate());
-        action.execute(tlsContext, executor);
+        action.execute(tlsContext);
         assertEquals(action.getOldValue(), TestCertificates.getTestCertificate());
     }
 
@@ -78,7 +78,7 @@ public class ChangeClientCertificateActionTest {
      */
     @Test
     public void testExecute() {
-        action.execute(tlsContext, executor);
+        action.execute(tlsContext);
         assertEquals(action.getNewValue(), TestCertificates.getTestCertificate());
     }
 
@@ -88,11 +88,11 @@ public class ChangeClientCertificateActionTest {
     @Test
     public void testReset() {
         assertFalse(action.isExecuted());
-        action.execute(tlsContext, executor);
+        action.execute(tlsContext);
         assertTrue(action.isExecuted());
         action.reset();
         assertFalse(action.isExecuted());
-        action.execute(tlsContext, executor);
+        action.execute(tlsContext);
         assertTrue(action.isExecuted());
     }
 
diff --git a/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeClientRandomActionTest.java b/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeClientRandomActionTest.java
index 84c9dc2d..64fe5afa 100644
--- a/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeClientRandomActionTest.java
+++ b/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeClientRandomActionTest.java
@@ -75,7 +75,7 @@ public class ChangeClientRandomActionTest {
     @Test
     public void testGetOldValue() {
         tlsContext.setClientRandom(new byte[] { 3 });
-        action.execute(tlsContext, executor);
+        action.execute(tlsContext);
         assertArrayEquals(action.getOldValue(), new byte[] { 3 });
     }
 
@@ -85,7 +85,7 @@ public class ChangeClientRandomActionTest {
     @Test
     public void testExecute() {
         tlsContext.setClientRandom(new byte[] { 3 });
-        action.execute(tlsContext, executor);
+        action.execute(tlsContext);
         assertArrayEquals(action.getOldValue(), new byte[] { 3 });
         assertArrayEquals(action.getNewValue(), new byte[] { 0, 1 });
         assertArrayEquals(tlsContext.getClientRandom(), new byte[] { 0, 1 });
@@ -99,11 +99,11 @@ public class ChangeClientRandomActionTest {
     @Test
     public void testReset() {
         assertFalse(action.isExecuted());
-        action.execute(tlsContext, executor);
+        action.execute(tlsContext);
         assertTrue(action.isExecuted());
         action.reset();
         assertFalse(action.isExecuted());
-        action.execute(tlsContext, executor);
+        action.execute(tlsContext);
         assertTrue(action.isExecuted());
     }
 
diff --git a/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeCompressionActionTest.java b/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeCompressionActionTest.java
index f74a1d1f..910b62e3 100644
--- a/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeCompressionActionTest.java
+++ b/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeCompressionActionTest.java
@@ -76,7 +76,7 @@ public class ChangeCompressionActionTest {
     @Test
     public void testGetOldValue() {
         tlsContext.setSelectedCompressionMethod(CompressionMethod.NULL);
-        action.execute(tlsContext, executor);
+        action.execute(tlsContext);
         assertEquals(action.getOldValue(), CompressionMethod.NULL);
     }
 
@@ -86,7 +86,7 @@ public class ChangeCompressionActionTest {
     @Test
     public void testExecute() {
         tlsContext.setSelectedCompressionMethod(CompressionMethod.NULL);
-        action.execute(tlsContext, executor);
+        action.execute(tlsContext);
         assertEquals(action.getOldValue(), CompressionMethod.NULL);
         assertEquals(action.getNewValue(), CompressionMethod.LZS);
         assertEquals(tlsContext.getSelectedCompressionMethod(), CompressionMethod.LZS);
@@ -99,11 +99,11 @@ public class ChangeCompressionActionTest {
     @Test
     public void testReset() {
         assertFalse(action.isExecuted());
-        action.execute(tlsContext, executor);
+        action.execute(tlsContext);
         assertTrue(action.isExecuted());
         action.reset();
         assertFalse(action.isExecuted());
-        action.execute(tlsContext, executor);
+        action.execute(tlsContext);
         assertTrue(action.isExecuted());
     }
 
diff --git a/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeMasterSecretActionTest.java b/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeMasterSecretActionTest.java
index 8c1f65c5..d15bc1bc 100644
--- a/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeMasterSecretActionTest.java
+++ b/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeMasterSecretActionTest.java
@@ -75,7 +75,7 @@ public class ChangeMasterSecretActionTest {
     @Test
     public void testGetOldValue() {
         tlsContext.setMasterSecret(new byte[] { 3 });
-        action.execute(tlsContext, executor);
+        action.execute(tlsContext);
         assertArrayEquals(action.getOldValue(), new byte[] { 3 });
     }
 
@@ -85,7 +85,7 @@ public class ChangeMasterSecretActionTest {
     @Test
     public void testExecute() {
         tlsContext.setMasterSecret(new byte[] { 3 });
-        action.execute(tlsContext, executor);
+        action.execute(tlsContext);
         assertArrayEquals(action.getOldValue(), new byte[] { 3 });
         assertArrayEquals(action.getNewValue(), new byte[] { 0, 1 });
         assertArrayEquals(tlsContext.getMasterSecret(), new byte[] { 0, 1 });
@@ -99,11 +99,11 @@ public class ChangeMasterSecretActionTest {
     @Test
     public void testReset() {
         assertFalse(action.isExecuted());
-        action.execute(tlsContext, executor);
+        action.execute(tlsContext);
         assertTrue(action.isExecuted());
         action.reset();
         assertFalse(action.isExecuted());
-        action.execute(tlsContext, executor);
+        action.execute(tlsContext);
         assertTrue(action.isExecuted());
     }
 
diff --git a/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/workflow/action/ChangePreMasterSecretActionTest.java b/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/workflow/action/ChangePreMasterSecretActionTest.java
index 720e1a6f..9669aad1 100644
--- a/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/workflow/action/ChangePreMasterSecretActionTest.java
+++ b/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/workflow/action/ChangePreMasterSecretActionTest.java
@@ -75,7 +75,7 @@ public class ChangePreMasterSecretActionTest {
     @Test
     public void testGetOldValue() {
         tlsContext.setPreMasterSecret(new byte[] { 3 });
-        action.execute(tlsContext, executor);
+        action.execute(tlsContext);
         assertArrayEquals(action.getOldValue(), new byte[] { 3 });
     }
 
@@ -85,7 +85,7 @@ public class ChangePreMasterSecretActionTest {
     @Test
     public void testExecute() {
         tlsContext.setPreMasterSecret(new byte[] { 3 });
-        action.execute(tlsContext, executor);
+        action.execute(tlsContext);
         assertArrayEquals(action.getOldValue(), new byte[] { 3 });
         assertArrayEquals(action.getNewValue(), new byte[] { 0, 1 });
         assertArrayEquals(tlsContext.getPreMasterSecret(), new byte[] { 0, 1 });
@@ -99,11 +99,11 @@ public class ChangePreMasterSecretActionTest {
     @Test
     public void testReset() {
         assertFalse(action.isExecuted());
-        action.execute(tlsContext, executor);
+        action.execute(tlsContext);
         assertTrue(action.isExecuted());
         action.reset();
         assertFalse(action.isExecuted());
-        action.execute(tlsContext, executor);
+        action.execute(tlsContext);
         assertTrue(action.isExecuted());
     }
 
diff --git a/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeProtocolVersionActionTest.java b/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeProtocolVersionActionTest.java
index 6dd36437..187d3192 100644
--- a/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeProtocolVersionActionTest.java
+++ b/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeProtocolVersionActionTest.java
@@ -76,7 +76,7 @@ public class ChangeProtocolVersionActionTest {
     @Test
     public void testGetOldValue() {
         tlsContext.setSelectedProtocolVersion(ProtocolVersion.TLS12);
-        action.execute(tlsContext, executor);
+        action.execute(tlsContext);
         assertEquals(action.getOldValue(), ProtocolVersion.TLS12);
     }
 
@@ -86,7 +86,7 @@ public class ChangeProtocolVersionActionTest {
     @Test
     public void testExecute() {
         tlsContext.setSelectedProtocolVersion(ProtocolVersion.TLS12);
-        action.execute(tlsContext, executor);
+        action.execute(tlsContext);
         assertEquals(action.getOldValue(), ProtocolVersion.TLS12);
         assertEquals(action.getNewValue(), ProtocolVersion.SSL2);
         assertEquals(tlsContext.getSelectedProtocolVersion(), ProtocolVersion.SSL2);
@@ -99,11 +99,11 @@ public class ChangeProtocolVersionActionTest {
     @Test
     public void testReset() {
         assertFalse(action.isExecuted());
-        action.execute(tlsContext, executor);
+        action.execute(tlsContext);
         assertTrue(action.isExecuted());
         action.reset();
         assertFalse(action.isExecuted());
-        action.execute(tlsContext, executor);
+        action.execute(tlsContext);
         assertTrue(action.isExecuted());
     }
 
diff --git a/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeServerCertificateActionTest.java b/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeServerCertificateActionTest.java
index 4f0141af..04782272 100644
--- a/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeServerCertificateActionTest.java
+++ b/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeServerCertificateActionTest.java
@@ -69,7 +69,7 @@ public class ChangeServerCertificateActionTest {
     @Test
     public void testGetOldValue() {
         tlsContext.setServerCertificate(TestCertificates.getTestCertificate());
-        action.execute(tlsContext, executor);
+        action.execute(tlsContext);
         assertEquals(action.getOldValue(), TestCertificates.getTestCertificate());
     }
 
@@ -78,7 +78,7 @@ public class ChangeServerCertificateActionTest {
      */
     @Test
     public void testExecute() {
-        action.execute(tlsContext, executor);
+        action.execute(tlsContext);
         assertEquals(action.getNewValue(), TestCertificates.getTestCertificate());
         // TODO Check that context has changed
     }
@@ -89,11 +89,11 @@ public class ChangeServerCertificateActionTest {
     @Test
     public void testReset() {
         assertFalse(action.isExecuted());
-        action.execute(tlsContext, executor);
+        action.execute(tlsContext);
         assertTrue(action.isExecuted());
         action.reset();
         assertFalse(action.isExecuted());
-        action.execute(tlsContext, executor);
+        action.execute(tlsContext);
         assertTrue(action.isExecuted());
     }
 
diff --git a/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeServerRandomActionTest.java b/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeServerRandomActionTest.java
index 91d89c3b..78585e27 100644
--- a/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeServerRandomActionTest.java
+++ b/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/workflow/action/ChangeServerRandomActionTest.java
@@ -75,7 +75,7 @@ public class ChangeServerRandomActionTest {
     @Test
     public void testGetOldValue() {
         tlsContext.setServerRandom(new byte[] { 3 });
-        action.execute(tlsContext, executor);
+        action.execute(tlsContext);
         assertArrayEquals(action.getOldValue(), new byte[] { 3 });
     }
 
@@ -85,7 +85,7 @@ public class ChangeServerRandomActionTest {
     @Test
     public void testExecute() {
         tlsContext.setServerRandom(new byte[] { 3 });
-        action.execute(tlsContext, executor);
+        action.execute(tlsContext);
         assertArrayEquals(action.getOldValue(), new byte[] { 3 });
         assertArrayEquals(action.getNewValue(), new byte[] { 0, 1 });
         assertArrayEquals(tlsContext.getServerRandom(), new byte[] { 0, 1 });
@@ -99,11 +99,11 @@ public class ChangeServerRandomActionTest {
     @Test
     public void testReset() {
         assertFalse(action.isExecuted());
-        action.execute(tlsContext, executor);
+        action.execute(tlsContext);
         assertTrue(action.isExecuted());
         action.reset();
         assertFalse(action.isExecuted());
-        action.execute(tlsContext, executor);
+        action.execute(tlsContext);
         assertTrue(action.isExecuted());
     }
 
diff --git a/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/workflow/action/DeactivateEncryptionActionTest.java b/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/workflow/action/DeactivateEncryptionActionTest.java
index 7249728c..bae32628 100644
--- a/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/workflow/action/DeactivateEncryptionActionTest.java
+++ b/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/workflow/action/DeactivateEncryptionActionTest.java
@@ -56,7 +56,7 @@ public class DeactivateEncryptionActionTest {
      */
     @Test
     public void testExecute() throws Exception {
-        action.execute(tlsContext, executor);
+        action.execute(tlsContext);
         assertTrue(action.isExecuted());
         // TODO Check that decryption is disabled
     }
@@ -67,11 +67,11 @@ public class DeactivateEncryptionActionTest {
     @Test
     public void testReset() {
         assertFalse(action.isExecuted());
-        action.execute(tlsContext, executor);
+        action.execute(tlsContext);
         assertTrue(action.isExecuted());
         action.reset();
         assertFalse(action.isExecuted());
-        action.execute(tlsContext, executor);
+        action.execute(tlsContext);
         assertTrue(action.isExecuted());
     }
 
diff --git a/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/workflow/action/MessageActionFactoryTest.java b/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/workflow/action/MessageActionFactoryTest.java
index 486c5808..bdcae3d6 100644
--- a/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/workflow/action/MessageActionFactoryTest.java
+++ b/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/workflow/action/MessageActionFactoryTest.java
@@ -53,7 +53,7 @@ public class MessageActionFactoryTest {
         action = MessageActionFactory.createAction(ConnectionEndType.SERVER, ConnectionEndType.SERVER,
                 new AlertMessage(config));
         assertEquals(action.getClass(), SendAction.class);
-        assertTrue(action.getConfiguredMessages().size() == 1);
+        assertTrue(action.getMessages().size() == 1);
     }
 
     /**
@@ -74,7 +74,7 @@ public class MessageActionFactoryTest {
         assertEquals(action.getClass(), ReceiveAction.class);
         action = MessageActionFactory.createAction(ConnectionEndType.SERVER, ConnectionEndType.SERVER, messages);
         assertEquals(action.getClass(), SendAction.class);
-        assertTrue(action.getConfiguredMessages().size() == 2);
+        assertTrue(action.getMessages().size() == 2);
     }
 
 }
diff --git a/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/workflow/action/ReceiveActionTest.java b/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/workflow/action/ReceiveActionTest.java
index a9cd2d02..9a50d96a 100644
--- a/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/workflow/action/ReceiveActionTest.java
+++ b/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/workflow/action/ReceiveActionTest.java
@@ -11,12 +11,14 @@ package de.rub.nds.tlsattacker.core.workflow.action;
 import de.rub.nds.tlsattacker.core.constants.AlertDescription;
 import de.rub.nds.tlsattacker.core.constants.AlertLevel;
 import de.rub.nds.tlsattacker.core.constants.CipherSuite;
+import de.rub.nds.tlsattacker.core.exceptions.WorkflowExecutionException;
 import de.rub.nds.tlsattacker.core.protocol.message.AlertMessage;
 import de.rub.nds.tlsattacker.core.record.cipher.RecordBlockCipher;
 import de.rub.nds.tlsattacker.core.record.layer.TlsRecordLayer;
 import de.rub.nds.tlsattacker.core.unittest.helper.ActionExecutorMock;
 import de.rub.nds.tlsattacker.core.workflow.TlsConfig;
 import de.rub.nds.tlsattacker.core.workflow.TlsContext;
+import java.io.IOException;
 import java.io.StringReader;
 import java.io.StringWriter;
 import java.security.InvalidAlgorithmParameterException;
@@ -64,8 +66,8 @@ public class ReceiveActionTest {
      */
     @Test
     public void testExecute() throws Exception {
-        action.execute(tlsContext, executor);
-        assertEquals(action.getConfiguredMessages(), action.getActualMessages());
+        action.execute(tlsContext);
+        assertEquals(action.getMessages(), action.getActualMessages());
         assertTrue(action.isExecuted());
     }
 
@@ -73,13 +75,13 @@ public class ReceiveActionTest {
      * Test of execute method, of class ReceiveAction.
      */
     @Test
-    public void testReset() {
+    public void testReset() throws WorkflowExecutionException, IOException {
         assertFalse(action.isExecuted());
-        action.execute(tlsContext, executor);
+        action.execute(tlsContext);
         assertTrue(action.isExecuted());
         action.reset();
         assertFalse(action.isExecuted());
-        action.execute(tlsContext, executor);
+        action.execute(tlsContext);
         assertTrue(action.isExecuted());
     }
 
diff --git a/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/workflow/action/SendActionTest.java b/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/workflow/action/SendActionTest.java
index 569e2d98..6acc2b16 100644
--- a/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/workflow/action/SendActionTest.java
+++ b/TLS-Core/src/test/java/de/rub/nds/tlsattacker/core/workflow/action/SendActionTest.java
@@ -39,7 +39,6 @@ public class SendActionTest {
 
     private TlsContext tlsContext;
 
-    private ActionExecutorMock executor;
     private SendAction action;
 
     @Before
@@ -49,13 +48,12 @@ public class SendActionTest {
         alert.setConfig(AlertLevel.FATAL, AlertDescription.DECRYPT_ERROR);
         alert.setDescription(AlertDescription.DECODE_ERROR.getValue());
         alert.setLevel(AlertLevel.FATAL.getValue());
-        executor = new ActionExecutorMock();
         tlsContext = new TlsContext();
         tlsContext.setSelectedCipherSuite(CipherSuite.TLS_DHE_DSS_WITH_AES_128_CBC_SHA);
         tlsContext.setRecordLayer(new TlsRecordLayer(tlsContext));
         tlsContext.getRecordLayer().setRecordCipher(new RecordBlockCipher(tlsContext));
         action = new SendAction(alert);
-        action.setConfiguredRecords(new LinkedList<AbstractRecord>());
+        action.setRecords(new LinkedList<AbstractRecord>());
     }
 
     @After
@@ -67,19 +65,18 @@ public class SendActionTest {
      */
     @Test
     public void testExecute() {
-        action.execute(tlsContext, executor);
-        assertEquals(action.getConfiguredMessages(), action.getActualMessages());
+        action.execute(tlsContext);
         assertTrue(action.isExecuted());
     }
 
     @Test
     public void testReset() {
         assertFalse(action.isExecuted());
-        action.execute(tlsContext, executor);
+        action.execute(tlsContext);
         assertTrue(action.isExecuted());
         action.reset();
         assertFalse(action.isExecuted());
-        action.execute(tlsContext, executor);
+        action.execute(tlsContext);
         assertTrue(action.isExecuted());
     }
 
diff --git a/Transport/src/main/java/de/rub/nds/tlsattacker/transport/SimpleTransportHandler.java b/Transport/src/main/java/de/rub/nds/tlsattacker/transport/SimpleTransportHandler.java
deleted file mode 100644
index 0ea8c560..00000000
--- a/Transport/src/main/java/de/rub/nds/tlsattacker/transport/SimpleTransportHandler.java
+++ /dev/null
@@ -1,172 +0,0 @@
-/**
- * TLS-Attacker - A Modular Penetration Testing Framework for TLS
- *
- * Copyright 2014-2017 Ruhr University Bochum / Hackmanit GmbH
- *
- * Licensed under Apache License 2.0
- * http://www.apache.org/licenses/LICENSE-2.0
- */
-package de.rub.nds.tlsattacker.transport;
-
-import de.rub.nds.modifiablevariable.util.ArrayConverter;
-import java.io.BufferedInputStream;
-import java.io.BufferedOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.net.ServerSocket;
-import java.net.Socket;
-import java.net.SocketException;
-import java.util.Arrays;
-
-/**
- * @author Juraj Somorovsky <juraj.somorovsky@rub.de>
- * @author Philip Riese <philip.riese@rub.de>
- */
-public class SimpleTransportHandler extends TransportHandler {
-
-    private Socket socket;
-
-    private ServerSocket serverSocket;
-
-    private boolean isServer = false;
-
-    private BufferedOutputStream bos;
-
-    private BufferedInputStream bis;
-
-    private byte[] readTimingData;
-
-    private int tlsTimeout;
-
-    public SimpleTransportHandler(String hostname, int port, ConnectionEndType end, int socketTimeout, int tlsTimeout) {
-        super(hostname, port, end, socketTimeout);
-        this.tlsTimeout = tlsTimeout;
-    }
-
-    @Override
-    public void initialize() throws IOException {
-        if (end == ConnectionEndType.SERVER) {
-            serverSocket = new ServerSocket(port);
-            LOGGER.info("Starting ServerTransportHandler on Port:" + port);
-            isServer = true;
-            socket = serverSocket.accept();
-            LOGGER.info("Acception connection from:" + socket.toString());
-        } else {
-            LOGGER.info("Connecting to " + hostname + ":" + port);
-            socket = new Socket(hostname, port);
-            LOGGER.info("Connected.");
-        }
-
-        OutputStream os = socket.getOutputStream();
-        bos = new BufferedOutputStream(os);
-
-        InputStream is = socket.getInputStream();
-        bis = new BufferedInputStream(is);
-    }
-
-    @Override
-    public void sendData(byte[] data) throws IOException {
-        LOGGER.debug("Sending data:" + ArrayConverter.bytesToHexString(data));
-        try {
-            bos.write(data);
-            // todo: this must be improved in the future versions, best approach
-            // would be to execute JNI calls or to execute the calls over a
-            // MitM server written in C
-            if (measuringTiming) {
-                byte[] tmp = new byte[2000];
-                bos.flush();
-                lastSystemNano = System.nanoTime();
-                int read = bis.read(tmp);
-                lastMeasurement = System.nanoTime() - lastSystemNano;
-                readTimingData = Arrays.copyOf(tmp, read);
-            } else {
-                bos.flush();
-            }
-        } catch (SocketException ex) {
-            // While connecting to a Java server, a "Connection reset" failure
-            // was received.Connection reset means that a TCP packet with the
-            // RST bit was received. The most common cause of this is an attempt
-            // to send to a partner that has closed its socket
-            LOGGER.debug("Connection reset was received by flushing the data. It is very probable that the peer"
-                    + " closed the socket after the last data was written. Thus, simply ignore this failure");
-        }
-    }
-
-    @Override
-    public byte[] fetchData() throws IOException {
-        byte[] response = new byte[0];
-        if (measuringTiming) {
-            measuringTiming = false;
-            response = readTimingData;
-        }
-        long minTimeMillies = System.currentTimeMillis() + socketTimeout;
-        // long maxTimeMillies = System.currentTimeMillis() + timeout;
-        while ((System.currentTimeMillis() < minTimeMillies) && (response.length == 0)) {
-            // while ((System.currentTimeMillis() < maxTimeMillies) &&
-            // (bis.available() != 0)) {
-            while (bis.available() != 0) {
-                // TODO: It is never correct to use the return value of this
-                // method to allocate a buffer intended to hold all data in this
-                // stream.
-                // http://docs.oracle.com/javase/7/docs/api/java/io/InputStream.html#available%28%29
-                byte[] current = new byte[bis.available()];
-                int readResult = bis.read(current);
-                if (readResult != -1) {
-                    response = ArrayConverter.concatenate(response, current);
-                    try {
-                        Thread.sleep(10);
-                    } catch (InterruptedException ex) {
-
-                    }
-                }
-            }
-        }
-        if (isServer) {
-            LOGGER.debug("Accepted {} new bytes from client", response.length);
-        } else {
-            LOGGER.debug("Accepted {} new bytes from server", response.length);
-        }
-        return response;
-    }
-
-    @Override
-    public void closeConnection() {
-        try {
-            if (bos != null) {
-                bos.close();
-            }
-        } catch (IOException e) {
-            LOGGER.debug(e);
-        }
-        try {
-            if (bis != null) {
-                bis.close();
-            }
-        } catch (IOException e) {
-            LOGGER.debug(e);
-        }
-        try {
-            if (socket != null) {
-                socket.close();
-            }
-        } catch (IOException e) {
-            LOGGER.debug(e);
-        }
-        try {
-            if (serverSocket != null) {
-                serverSocket.close();
-            }
-        } catch (IOException e) {
-            LOGGER.debug(e);
-        }
-    }
-
-    public long getTlsTimeout() {
-        return tlsTimeout;
-    }
-
-    public void setTlsTimeout(int tlsTimeout) {
-        this.tlsTimeout = tlsTimeout;
-    }
-}
diff --git a/Transport/src/main/java/de/rub/nds/tlsattacker/transport/TCPClientTransportHandler.java b/Transport/src/main/java/de/rub/nds/tlsattacker/transport/TCPClientTransportHandler.java
new file mode 100644
index 00000000..9c732145
--- /dev/null
+++ b/Transport/src/main/java/de/rub/nds/tlsattacker/transport/TCPClientTransportHandler.java
@@ -0,0 +1,49 @@
+/**
+ * TLS-Attacker - A Modular Penetration Testing Framework for TLS
+ *
+ * Copyright 2014-2017 Ruhr University Bochum / Hackmanit GmbH
+ *
+ * Licensed under Apache License 2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
+ */
+package de.rub.nds.tlsattacker.transport;
+
+import java.io.IOException;
+import java.net.Socket;
+
+/**
+ * @author Juraj Somorovsky <juraj.somorovsky@rub.de>
+ * @author Philip Riese <philip.riese@rub.de>
+ */
+public class TCPClientTransportHandler extends TransportHandler {
+
+    private Socket socket;
+
+    private String hostname;
+
+    private int port;
+
+    public TCPClientTransportHandler(String hostname, int port, long timeout) {
+        super(timeout);
+        this.hostname = hostname;
+        this.port = port;
+    }
+
+    @Override
+    public void initialize() throws IOException {
+        LOGGER.info("Connecting to " + hostname + ":" + port);
+        socket = new Socket(hostname, port);
+        LOGGER.info("Connected.");
+    }
+
+    @Override
+    public void closeConnection() {
+        try {
+            if (socket != null) {
+                socket.close();
+            }
+        } catch (IOException e) {
+            LOGGER.debug(e);
+        }
+    }
+}
diff --git a/Transport/src/main/java/de/rub/nds/tlsattacker/transport/TransportHandler.java b/Transport/src/main/java/de/rub/nds/tlsattacker/transport/TransportHandler.java
index fe7ec19d..f742ee3f 100644
--- a/Transport/src/main/java/de/rub/nds/tlsattacker/transport/TransportHandler.java
+++ b/Transport/src/main/java/de/rub/nds/tlsattacker/transport/TransportHandler.java
@@ -9,6 +9,8 @@
 package de.rub.nds.tlsattacker.transport;
 
 import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
@@ -19,53 +21,46 @@ public abstract class TransportHandler {
 
     protected static final Logger LOGGER = LogManager.getLogger("Transport");
 
-    protected int socketTimeout;
+    private OutputStream outStream;
 
-    protected long lastSystemNano;
+    private InputStream inStream;
 
-    protected long lastMeasurement;
+    protected long timeout;
 
-    protected boolean measuringTiming;
-
-    protected ConnectionEndType end;
-
-    protected String hostname;
-
-    protected int port;
+    public TransportHandler(long timeout) {
+        this.timeout = timeout;
+    }
 
-    public TransportHandler(String hostname, int port, ConnectionEndType end, int socketTimeout) {
-        this.end = end;
-        this.socketTimeout = socketTimeout;
-        this.hostname = hostname;
-        this.port = port;
+    public void setStreams(InputStream inStream, OutputStream outStream) {
+        this.outStream = outStream;
+        this.inStream = inStream;
     }
 
     public abstract void closeConnection();
 
-    public abstract byte[] fetchData() throws IOException;
-
-    public abstract void initialize() throws IOException;
-
-    public abstract void sendData(byte[] data) throws IOException;
-
-    public String getHostname() {
-        return hostname;
+    public byte[] fetchData() throws IOException {
+        int available;
+        long startTime = System.currentTimeMillis();
+        do {
+            available = inStream.available();
+        } while (available == 0 && startTime + timeout < System.currentTimeMillis());
+        byte[] receivedBytes = new byte[available];
+        inStream.read(receivedBytes);
+        return receivedBytes;
     }
 
-    public int getPort() {
-        return port;
-    }
+    public abstract void initialize() throws IOException;
 
-    public void measureTiming(boolean b) {
-        measuringTiming = b;
+    public void sendData(byte[] data) throws IOException {
+        outStream.write(data);
+        outStream.flush();
     }
 
-    public long getLastMeasurement() {
-        return lastMeasurement;
+    public long getTimeout() {
+        return timeout;
     }
 
-    public boolean isMeasuringTiming() {
-        return measuringTiming;
+    public void setTimeout(long timeout) {
+        this.timeout = timeout;
     }
-
 }
diff --git a/Transport/src/main/java/de/rub/nds/tlsattacker/transport/TransportHandlerFactory.java b/Transport/src/main/java/de/rub/nds/tlsattacker/transport/TransportHandlerFactory.java
index b50f1dae..4e8ff265 100644
--- a/Transport/src/main/java/de/rub/nds/tlsattacker/transport/TransportHandlerFactory.java
+++ b/Transport/src/main/java/de/rub/nds/tlsattacker/transport/TransportHandlerFactory.java
@@ -14,14 +14,20 @@ package de.rub.nds.tlsattacker.transport;
 public class TransportHandlerFactory {
 
     public static TransportHandler createTransportHandler(String hostname, int port, ConnectionEndType end,
-            int tlsTimeout, int socketTimeout, TransportHandlerType type) {
+            int timeout, TransportHandlerType type) {
         switch (type) {
             case TCP:
-                return new SimpleTransportHandler(hostname, port, end, socketTimeout, tlsTimeout);
-            case EAP_TLS:
-                throw new UnsupportedOperationException("EAP_TLS is currently not supported");
+                if (end == ConnectionEndType.CLIENT) {
+                    return new TCPClientTransportHandler(hostname, port, timeout);
+                } else {
+                    return new TCPServerTransportHandler(port, timeout);
+                }
             case UDP:
-                return new UDPTransportHandler(hostname, port, end, tlsTimeout);
+                if (end == ConnectionEndType.CLIENT) {
+                    return new UDPClientTransportHandler(hostname, port, timeout);
+                } else {
+                    return new UDPServerTransportHandler(port, timeout);
+                }
             default:
                 throw new UnsupportedOperationException("This transport handler " + "type is not supported");
         }
diff --git a/Transport/src/main/java/de/rub/nds/tlsattacker/transport/UDPClientTransportHandler.java b/Transport/src/main/java/de/rub/nds/tlsattacker/transport/UDPClientTransportHandler.java
new file mode 100644
index 00000000..66eeed86
--- /dev/null
+++ b/Transport/src/main/java/de/rub/nds/tlsattacker/transport/UDPClientTransportHandler.java
@@ -0,0 +1,68 @@
+/**
+ * TLS-Attacker - A Modular Penetration Testing Framework for TLS
+ *
+ * Copyright 2014-2017 Ruhr University Bochum / Hackmanit GmbH
+ *
+ * Licensed under Apache License 2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
+ */
+package de.rub.nds.tlsattacker.transport;
+
+import de.rub.nds.tlsattacker.transport.stream.UDPInputStream;
+import de.rub.nds.tlsattacker.transport.stream.UDPOutputStream;
+import java.io.IOException;
+import java.net.DatagramPacket;
+import java.net.DatagramSocket;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.nio.channels.DatagramChannel;
+
+/**
+ * @author Florian Pfützenreuter <Florian.Pfuetzenreuter@rub.de>
+ */
+public class UDPClientTransportHandler extends TransportHandler {
+
+    private DatagramSocket datagramSocket;
+
+    private final String hostname;
+
+    private final int port;
+
+    public UDPClientTransportHandler(String hostname, int port, long timeout) {
+        super(timeout);
+        this.port = port;
+        this.hostname = hostname;
+    }
+
+    @Override
+    public void initialize() throws IOException {
+        DatagramChannel channel = DatagramChannel.open();
+        datagramSocket = channel.socket();
+        datagramSocket.connect(new InetSocketAddress(InetAddress.getByName(hostname), port));
+        datagramSocket.setSoTimeout(1);
+        if (LOGGER.isDebugEnabled()) {
+            StringBuilder logOut = new StringBuilder();
+            logOut.append("Socket bound to \"");
+            logOut.append(datagramSocket.getLocalAddress().getCanonicalHostName());
+            logOut.append(":");
+            logOut.append(datagramSocket.getLocalPort());
+            logOut.append("\". Specified remote host and port: \"");
+            logOut.append(datagramSocket.getInetAddress().getCanonicalHostName());
+            logOut.append(":");
+            logOut.append(datagramSocket.getPort());
+            logOut.append("\".");
+            LOGGER.debug(logOut.toString());
+        }
+        setStreams(new UDPInputStream(datagramSocket), new UDPOutputStream(datagramSocket));
+    }
+
+    @Override
+    public void closeConnection() {
+        datagramSocket.close();
+        LOGGER.debug("Socket closed.");
+    }
+
+    public int getLocalPort() {
+        return datagramSocket.getLocalPort();
+    }
+}
diff --git a/Transport/src/main/java/de/rub/nds/tlsattacker/transport/UDPServerTransportHandler.java b/Transport/src/main/java/de/rub/nds/tlsattacker/transport/UDPServerTransportHandler.java
new file mode 100644
index 00000000..d7a5ae19
--- /dev/null
+++ b/Transport/src/main/java/de/rub/nds/tlsattacker/transport/UDPServerTransportHandler.java
@@ -0,0 +1,60 @@
+/**
+ * TLS-Attacker - A Modular Penetration Testing Framework for TLS
+ *
+ * Copyright 2014-2017 Ruhr University Bochum / Hackmanit GmbH
+ *
+ * Licensed under Apache License 2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
+ */
+package de.rub.nds.tlsattacker.transport;
+
+import static de.rub.nds.tlsattacker.transport.TransportHandler.LOGGER;
+import de.rub.nds.tlsattacker.transport.stream.UDPInputStream;
+import de.rub.nds.tlsattacker.transport.stream.UDPOutputStream;
+import java.io.IOException;
+import java.net.DatagramSocket;
+
+/**
+ * @author Florian Pfützenreuter <Florian.Pfuetzenreuter@rub.de>
+ */
+public class UDPServerTransportHandler extends TransportHandler {
+
+    private DatagramSocket datagramSocket;
+
+    private final int port;
+
+    public UDPServerTransportHandler(int port, long timeout) {
+        super(timeout);
+        this.port = port;
+    }
+
+    @Override
+    public void initialize() throws IOException {
+        datagramSocket = new DatagramSocket(port);
+        //datagramSocket.setSoTimeout((int) timeout);
+        if (LOGGER.isDebugEnabled()) {
+            StringBuilder logOut = new StringBuilder();
+            logOut.append("Socket bound to \"");
+            logOut.append(datagramSocket.getLocalAddress().getCanonicalHostName());
+            logOut.append(":");
+            logOut.append(datagramSocket.getLocalPort());
+            logOut.append("\". Specified remote host and port: \"");
+            logOut.append(datagramSocket.getInetAddress().getCanonicalHostName());
+            logOut.append(":");
+            logOut.append(datagramSocket.getPort());
+            logOut.append("\".");
+            LOGGER.debug(logOut.toString());
+        }
+        setStreams(new UDPInputStream(datagramSocket), new UDPOutputStream(datagramSocket));
+    }
+
+    @Override
+    public void closeConnection() {
+        datagramSocket.close();
+        LOGGER.debug("Socket closed.");
+    }
+
+    public int getLocalPort() {
+        return datagramSocket.getLocalPort();
+    }
+}
diff --git a/Transport/src/main/java/de/rub/nds/tlsattacker/transport/UDPTransportHandler.java b/Transport/src/main/java/de/rub/nds/tlsattacker/transport/UDPTransportHandler.java
deleted file mode 100644
index d3c277a8..00000000
--- a/Transport/src/main/java/de/rub/nds/tlsattacker/transport/UDPTransportHandler.java
+++ /dev/null
@@ -1,113 +0,0 @@
-/**
- * TLS-Attacker - A Modular Penetration Testing Framework for TLS
- *
- * Copyright 2014-2017 Ruhr University Bochum / Hackmanit GmbH
- *
- * Licensed under Apache License 2.0
- * http://www.apache.org/licenses/LICENSE-2.0
- */
-package de.rub.nds.tlsattacker.transport;
-
-import java.io.IOException;
-import java.net.DatagramPacket;
-import java.net.DatagramSocket;
-import java.net.InetAddress;
-import java.net.SocketException;
-import java.util.Arrays;
-
-/**
- * @author Florian Pfützenreuter <Florian.Pfuetzenreuter@rub.de>
- */
-public class UDPTransportHandler extends TransportHandler {
-
-    private DatagramSocket datagramSocket;
-
-    private final DatagramPacket receivedPacket = new DatagramPacket(new byte[65527], 65527);
-
-    private DatagramPacket sentPacket;
-
-    private long responseNanos = -1;
-
-    public UDPTransportHandler(String hostname, int port, ConnectionEndType end, int timeout) {
-        super(hostname, port, end, timeout);
-        this.socketTimeout = timeout;
-    }
-
-    @Override
-    public void initialize() throws IOException {
-        datagramSocket = new DatagramSocket();
-        datagramSocket.setSoTimeout(socketTimeout);
-        datagramSocket.connect(InetAddress.getByName(hostname), port);
-
-        sentPacket = new DatagramPacket(new byte[0], 0, datagramSocket.getInetAddress(), datagramSocket.getPort());
-
-        if (LOGGER.isDebugEnabled()) {
-            StringBuilder logOut = new StringBuilder();
-            logOut.append("Socket bound to \"");
-            logOut.append(datagramSocket.getLocalAddress().getCanonicalHostName());
-            logOut.append(":");
-            logOut.append(datagramSocket.getLocalPort());
-            logOut.append("\". Specified remote host and port: \"");
-            logOut.append(datagramSocket.getInetAddress().getCanonicalHostName());
-            logOut.append(":");
-            logOut.append(datagramSocket.getPort());
-            logOut.append("\".");
-            LOGGER.debug(logOut.toString());
-        }
-    }
-
-    @Override
-    public void sendData(byte[] data) throws IOException {
-        sentPacket.setData(data, 0, data.length);
-        datagramSocket.send(sentPacket);
-    }
-
-    @Override
-    public byte[] fetchData() throws IOException {
-        responseNanos = System.nanoTime();
-        datagramSocket.receive(receivedPacket);
-        responseNanos = System.nanoTime() - responseNanos;
-        return Arrays.copyOfRange(receivedPacket.getData(), 0, receivedPacket.getLength());
-    }
-
-    @Override
-    public void closeConnection() {
-        datagramSocket.close();
-        LOGGER.debug("Socket closed.");
-    }
-
-    public int getTlsTimeout() {
-        return socketTimeout;
-    }
-
-    public void setTlsTimeout(int tlsTimeout) {
-        this.socketTimeout = tlsTimeout;
-        if (datagramSocket != null) {
-            try {
-                datagramSocket.setSoTimeout(this.socketTimeout);
-            } catch (SocketException e) {
-                LOGGER.debug("Failed to set socket timeout. Exception:\n{}", e.getMessage());
-            }
-        }
-    }
-
-    public int getLocalPort() {
-        return datagramSocket.getLocalPort();
-    }
-
-    public InetAddress getLocalAddress() {
-        return datagramSocket.getLocalAddress();
-    }
-
-    public int getRemotePort() {
-        return datagramSocket.getPort();
-    }
-
-    public InetAddress getRemoteAddress() {
-        return datagramSocket.getInetAddress();
-    }
-
-    public long getResponseTimeNanos() {
-        return responseNanos;
-    }
-}
diff --git a/Transport/src/test/java/de/rub/nds/tlsattacker/transport/UDPTransportHandlerTest.java b/Transport/src/test/java/de/rub/nds/tlsattacker/transport/UDPTransportHandlerTest.java
index 1f75b865..882d17b6 100644
--- a/Transport/src/test/java/de/rub/nds/tlsattacker/transport/UDPTransportHandlerTest.java
+++ b/Transport/src/test/java/de/rub/nds/tlsattacker/transport/UDPTransportHandlerTest.java
@@ -13,8 +13,10 @@ import de.rub.nds.modifiablevariable.util.RandomHelper;
 import java.net.DatagramPacket;
 import java.net.DatagramSocket;
 import java.net.InetAddress;
+import java.net.InetSocketAddress;
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
 import org.junit.Test;
 
 /**
@@ -30,9 +32,11 @@ public class UDPTransportHandlerTest {
 
     @Test
     public void testSendData() throws Exception {
-        try (DatagramSocket testSocket = new DatagramSocket()) {
-            UDPTransportHandler udpTH = new UDPTransportHandler(localhost.getHostName(), testSocket.getLocalPort(),
-                    ConnectionEndType.CLIENT, 400);
+        try {
+            UDPClientTransportHandler udpTH = new UDPClientTransportHandler(localhost.getHostName(),
+                    1234, 400);
+            DatagramSocket testSocket = new DatagramSocket(4444);
+
             testSocket.setSoTimeout(1000);
 
             udpTH.initialize();
@@ -40,7 +44,7 @@ public class UDPTransportHandlerTest {
             byte[] txData = new byte[8192];
             RandomHelper.getRandom().nextBytes(txData);
             byte[] rxData = new byte[8192];
-            DatagramPacket rxPacket = new DatagramPacket(rxData, rxData.length, localhost, testSocket.getLocalPort());
+            DatagramPacket rxPacket = new DatagramPacket(rxData, rxData.length, localhost, 1234);
 
             udpTH.sendData(txData);
             testSocket.receive(rxPacket);
@@ -49,18 +53,21 @@ public class UDPTransportHandlerTest {
             assertArrayEquals("Confirm sent data equals received data", txData, rxPacket.getData());
 
             udpTH.closeConnection();
+        } catch (Exception E) {
+            E.printStackTrace();
+            fail();
         }
     }
 
     @Test
     public void testFetchData() throws Exception {
-        try (DatagramSocket testSocket = new DatagramSocket()) {
-            UDPTransportHandler udpTH = new UDPTransportHandler(localhost.getHostName(), testSocket.getLocalPort(),
-                    ConnectionEndType.CLIENT, 400);
-
-            udpTH.initialize();
-            testSocket.connect(localhost, udpTH.getLocalPort());
-            udpTH.setTlsTimeout(1);
+        try {
+            UDPClientTransportHandler udpTransportHandler = new UDPClientTransportHandler(localhost.getHostName(),
+                    4444, 400);
+            udpTransportHandler.initialize();
+            
+            DatagramSocket testSocket = new DatagramSocket(new InetSocketAddress(udpTransportHandler.getLocalPort()));
+            testSocket.connect(localhost, udpTransportHandler.getLocalPort());
 
             byte[] allSentData = new byte[0];
             byte[] allReceivedData = new byte[0];
@@ -68,21 +75,23 @@ public class UDPTransportHandlerTest {
             byte[] rxData;
             DatagramPacket txPacket;
             int numTestPackets = 100;
-
             for (int i = 0; i < numTestPackets; i++) {
                 txData = new byte[RandomHelper.getRandom().nextInt(16383) + 1];
                 RandomHelper.getRandom().nextBytes(txData);
-                txPacket = new DatagramPacket(txData, txData.length, localhost, udpTH.getLocalPort());
+                txPacket = new DatagramPacket(txData, txData.length, localhost, udpTransportHandler.getLocalPort());
                 testSocket.send(txPacket);
                 allSentData = ArrayConverter.concatenate(allSentData, txData);
-                rxData = udpTH.fetchData();
+                rxData = udpTransportHandler.fetchData();
                 allReceivedData = ArrayConverter.concatenate(allReceivedData, rxData);
             }
 
             assertEquals("Confirm size of the received data", allSentData.length, allReceivedData.length);
             assertArrayEquals("Confirm received data equals sent data", allSentData, allReceivedData);
 
-            udpTH.closeConnection();
+            udpTransportHandler.closeConnection();
+        } catch (Exception E) {
+            E.printStackTrace();
+            fail();
         }
     }
 }
